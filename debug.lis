     1                                  ;========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1=========2=========3=========4=========5=====
     2                                  ;Author information
     3                                  ;  Author name: Floyd Holliday
     4                                  ;  Author email: holliday@fullerton.edu
     5                                  ;Course information
     6                                  ;  Course number: CPSC240
     7                                  ;  Assignment number: 00
     8                                  ;  Due date (Date of last modification): 2014-Feb-05
     9                                  ;Project information
    10                                  ;  Project title: X86 Assembly Debugger
    11                                  ;  Purpose: Show contents of registers, stack, and arrays.  This is a tool used by assembly programmers during the development phase.
    12                                  ;  Status: In development
    13                                  ;  Project files: debug.inc, debug.asm
    14                                  ;  Modules (subprograms): showregisters, dumpstack, showfpusubprogram, showxmmregisters, showymmregisters
    15                                  ;  Those five subprograms are contained within this debug.asm file.
    16                                  ;Translator information
    17                                  ;  Linux: nasm -f elf64 -l debug.lis -o debug.o debug.asm
    18                                  ;References and credits
    19                                  ;  Dr. Paul Carter: www.drpaulcarter.com
    20                                  ;Format information
    21                                  ;  Page width: 156 columns
    22                                  ;  Begin comments: 61
    23                                  ;  Optimal print specification: Landscape orientation, 8 points or smaller, monospace, 8Â½x11 paper
    24                                  ;Information for users  
    25                                  ;  Make this Debug tool available for your own software.  First assemble this file.  Place the include statement |%include "debug.inc"|
    26                                  ;  excluding the vertical bars in your source code at the beginning.  Typically this include directive is the first statement other
    27                                  ;  than comments in a program.
    28                                  ;Future enhancements pending
    29                                  ;  Make the showregisters program backup the SSE registers
    30                                  ;  Localize all identifiers to their own subprogram in order that no identifier conflict with another identifier in this file.
    31                                  
    32                                  ;==========================================================================================================================================================
    33                                  ;===== General facts used in Debug ========================================================================================================================
    34                                  ;==========================================================================================================================================================
    35                                  ;CCC-64 sequence of parameters (left to right):
    36                                  ;  1st  rdi
    37                                  ;  2nd  rsi
    38                                  ;  3nd  rdx
    39                                  ;  4rd  rcx
    40                                  ;  5th  r8
    41                                  ;  6th  r9
    42                                  ;  remainder on stack right to left
    43                                  
    44                                  ;Regarding which format specifier to use: the following appear to hold:
    45                                  ; "%x" designates 32-bit hex output with leading zeros suppressed.
    46                                  ; "%lx" designates 64-bit hex output
    47                                  ; "%llx" designates 128-bit hex output
    48                                  ; "%lllx" designates 256-bit hex output
    49                                  ; "%llld" designates 256-bit decimal output
    50                                  ; "%8x" designates 32-bit hex output in 8 columns
    51                                  ; "%016lx" designates 64-bit hex output in 16 columns with leading zeros displayed.
    52                                  ; "%lu" designates 64-bit unsigned integer.
    53                                  
    54                                  ;==========================================================================================================================================================
    55                                  ;===== Begin subprogram showregisters =====================================================================================================================
    56                                  ;===== Begin subprogram showregisters =====================================================================================================================
    57                                  ;===== Begin subprogram showregisters =====================================================================================================================
    58                                  ;==========================================================================================================================================================
    59                                  ;Module information
    60                                  ;  This module's call name: showregisterssubprogram
    61                                  ;  Language: X86-64
    62                                  ;  Syntax: Intel
    63                                  ;  Date last modified: 2014-Jan-8
    64                                  ;  Purpose: This module will show the contents of all integer registers including the flags register.
    65                                  ;  Status: The present source code is in production.
    66                                  ;  Future enhancements: Backup the SSE registers.  Find how to detect the presence of AVE and backup AVE only when present.
    67                                  
    68                                  ;X86 rflags register:
    69                                  ;Bit# Mnemonic Name
    70                                  ;  0     CF    Carry flag
    71                                  ;  1           unused
    72                                  ;  2     PF    Parity flag
    73                                  ;  3           unused
    74                                  ;  4     AF    Auxiliary Carry flag
    75                                  ;  5           unused
    76                                  ;  6     ZF    Zero flag
    77                                  ;  7     SF    Sign flag
    78                                  ;  8     TF    Trap flag
    79                                  ;  9     IF    Interrupt flag
    80                                  ; 10     DF    Direction flag
    81                                  ; 11     OF    Overflow flag
    82                                  
    83                                  ;===== Expected format of the output ===================================================================================================
    84                                  ;Register Dump # 132
    85                                  ;rax = 0000000000000003 rbx = 0000000000000000 rcx = 0000000000000001 rdx = 00007f59b444aab0
    86                                  ;rsi = 0000000000000003 rdi = 0000000000602ad0 rbp = 00007fff7d9a6960 rsp = 00007fff7d9a6900
    87                                  ;r8  = 00007f59b496e01b r9  = 0000000000000001 r10 = 0000000000000000 r11 = 0000000000000246
    88                                  ;r12 = 0000000000000003 r13 = 00007fff7d9a6a40 r14 = 0000000000000019 r15 = 0000000000000000
    89                                  ;rip = 00000000004008bf
    90                                  ;rflags = 0000000000000246 of = 0 sf = 0 zf = 1 af = 0 pf = 1 cf = 0
    91                                  
    92                                  
    93                                  ;===== Define constants ================================================================================================================
    94                                  ;Set constants via assembler directives
    95                                  %define qwordsize 8                     ;8 bytes
    96                                  %define cmask 00000001h                 ;Carry mask
    97                                  %define pmask 00000004h                 ;Parity mask
    98                                  %define amask 00000010h                 ;Auxiliary mask
    99                                  %define zmask 00000040h                 ;Zero mask
   100                                  %define smask 00000080h                 ;Sign mask
   101                                  %define dmask 00000400h                 ;Not used
   102                                  %define omask 00000800h                 ;Overflow mask
   103                                  
   104                                  
   105                                  extern printf                                               ;printf will be available to the linker in a binary format
   106                                  
   107                                  global showregisterssubprogram                              ;Make this subprogram callable from outside this file
   108                                  
   109                                  segment .data                                               ;This segment declares initialized data
   110                                  
   111 00000000 526567697374657220-     registerformat1 db "Register Dump # %ld", 10,
   112 00000009 44756D70202320256C-
   113 00000012 640A               
   114 00000014 726178203D20253031-                     db "rax = %016lx rbx = %016lx rcx = %016lx rdx = %016lx", 10,
   115 0000001D 366C7820726278203D-
   116 00000026 20253031366C782072-
   117 0000002F 6378203D2025303136-
   118 00000038 6C7820726478203D20-
   119 00000041 253031366C780A     
   120 00000048 727369203D20253031-                     db "rsi = %016lx rdi = %016lx rbp = %016lx rsp = %016lx", 10, 0
   121 00000051 366C7820726469203D-
   122 0000005A 20253031366C782072-
   123 00000063 6270203D2025303136-
   124 0000006C 6C7820727370203D20-
   125 00000075 253031366C780A00   
   126                                  
   127 0000007D 723820203D20253031-     registerformat2 db "r8  = %016lx r9  = %016lx r10 = %016lx r11 = %016lx", 10,
   128 00000086 366C7820723920203D-
   129 0000008F 20253031366C782072-
   130 00000098 3130203D2025303136-
   131 000000A1 6C7820723131203D20-
   132 000000AA 253031366C780A     
   133 000000B1 723132203D20253031-                     db "r12 = %016lx r13 = %016lx r14 = %016lx r15 = %016lx", 10, 0
   134 000000BA 366C7820723133203D-
   135 000000C3 20253031366C782072-
   136 000000CC 3134203D2025303136-
   137 000000D5 6C7820723135203D20-
   138 000000DE 253031366C780A00   
   139                                  
   140 000000E6 726970203D20253031-     registerformat3 db "rip = %016lx", 10, "rflags = %016lx ",
   141 000000EF 366C780A72666C6167-
   142 000000F8 73203D20253031366C-
   143 00000101 7820               
   144 00000103 6F66203D2025317820-                     db "of = %1x sf = %1x zf = %1x af = %1x pf = %1x cf = %1x", 10, 0
   145 0000010C 7366203D2025317820-
   146 00000115 7A66203D2025317820-
   147 0000011E 6166203D2025317820-
   148 00000127 7066203D2025317820-
   149 00000130 6366203D202531780A-
   150 00000139 00                 
   151                                  
   152 0000013A 5761726E696E673A20-     temporarymessage db "Warning: SSE is not backed up; you must backup SSE yourself.", 10, 0
   153 00000143 535345206973206E6F-
   154 0000014C 74206261636B656420-
   155 00000155 75703B20796F75206D-
   156 0000015E 757374206261636B75-
   157 00000167 702053534520796F75-
   158 00000170 7273656C662E0A00   
   159                                  
   160                                  segment .text                                               ;Executable instruction are in this segment
   161                                  
   162                                  showregisterssubprogram:                                    ;Execution begins here
   163                                  
   164                                  ;When using this subprogram many registers will be modified; however, rsp and rip are intentionally not modified.
   165                                  
   166                                  ;===== Back up all integer registers used in this subprogram ===========================================================================
   167 00000000 54                      push rsp                                                    ;Save a copy of rsp; rsp will not be restored
   168 00000001 50                      push rax                                                    ;Backup rax
   169 00000002 55                      push rbp                                                    ;Backup rbp
   170 00000003 57                      push rdi                                                    ;Backup rdi
   171 00000004 56                      push rsi                                                    ;Backup rsi
   172 00000005 52                      push rdx                                                    ;Backup rdx
   173 00000006 51                      push rcx                                                    ;Backup rcx
   174 00000007 4150                    push r8                                                     ;Backup r8
   175 00000009 4151                    push r9                                                     ;Backup r9
   176 0000000B 4152                    push r10                                                    ;Backup r10
   177 0000000D 4153                    push r11                                                    ;Backup r11
   178 0000000F 4154                    push r12                                                    ;Backup r12
   179 00000011 4155                    push r13                                                    ;Backup r13
   180 00000013 4156                    push r14                                                    ;Backup r14
   181 00000015 4157                    push r15                                                    ;Backup r15
   182 00000017 53                      push rbx                                                    ;Backup rbx
   183 00000018 9C                      pushf                                                       ;Backup rflags
   184                                  ;Register rip is not saved.  Register rsp is a special case.  The value of rsp pushed above is not the value of rsp when the subprogram 
   185                                  ;showregisters was called.  The fact is that two pushes have occurred between the time of the call to showregisters and the push rsp above.
   186                                  ;Therefore, the value of rsp at the time of the call can be obtained by adding 16 to the value stored due to push rsp.
   187                                  
   188                                  ;===== State of the integer stack at this time =========================================================================================
   189                                  
   190                                  ;              |---------------------------|
   191                                  ;     rsp+18*8 | arbitrary number from user|
   192                                  ;              |---------------------------|
   193                                  ;     rsp+17*8 | return address            |
   194                                  ;              |---------------------------|
   195                                  ;     rsp+16*8 | rsp                       | <== Contains a value 16 too small.
   196                                  ;              |---------------------------|
   197                                  ;     rsp+15*8 | rax                       |
   198                                  ;              |---------------------------|
   199                                  ;     rsp+14*8 | rbp                       |
   200                                  ;              |---------------------------|
   201                                  ;     rsp+13*8 | rdi                       |
   202                                  ;              |---------------------------|
   203                                  ;     rsp+12*8 | rsi                       |
   204                                  ;              |---------------------------|
   205                                  ;     rsp+11*8 | rdx                       |
   206                                  ;              |---------------------------|
   207                                  ;     rsp+10*8 | rcx                       |
   208                                  ;              |---------------------------|
   209                                  ;     rsp+9*8  | r8                        |
   210                                  ;              |---------------------------|
   211                                  ;     rsp+8*8  | r9                        |
   212                                  ;              |---------------------------|
   213                                  ;     rsp+7*8  | r10                       |
   214                                  ;              |---------------------------|
   215                                  ;     rsp+6*8  | r11                       |
   216                                  ;              |---------------------------|
   217                                  ;     rsp+5*8  | r12                       |
   218                                  ;              |---------------------------|
   219                                  ;     rsp+4*8  | r13                       |
   220                                  ;              |---------------------------|
   221                                  ;     rsp+3*8  | r14                       |
   222                                  ;              |---------------------------|
   223                                  ;     rsp+2*8  | r15                       |
   224                                  ;              |---------------------------|
   225                                  ;     rsp+1*8  | rbx                       |
   226                                  ;              |---------------------------|
   227                                  ;     rsp+0    | rflags                    |
   228                                  ;              |---------------------------|
   229                                  ;
   230                                  ;===== Back up the SSE2 registers: copy all xmm values to the integer stack ============================================================
   231                                  
   232                                       ;===== Temporary section warning users that SSE registers are not backed up =======================================================
   233 00000019 B800000000                   mov qword rax, 0                                       ;No data from SSE will be outputted
   234 0000001E 48BF-                        mov rdi, temporarymessage                              ;"Warning: SSE is not backed up; you must backup SSE yourself"
   235 00000020 [3A01000000000000] 
   236 00000028 E8(00000000)                 call printf
   237                                       ;==================================================================================================================================
   238                                  
   239                                  
   240                                  ;Caveat: There are 32 pushes below.  This will alter drastically the state of the integer stack immediately below.  Be prepared.
   241                                  ;Study carefully the instructions of showregisters subprogram before uncommenting any of the statements below.
   242                                  
   243                                  ;push qword 0
   244                                  ;push qword 0
   245                                  ;movupd     [rsp], xmm15
   246                                  ;push qword 0
   247                                  ;push qword 0
   248                                  ;movupd     [rsp], xmm14
   249                                  ;push qword 0
   250                                  ;push qword 0
   251                                  ;movupd     [rsp], xmm13
   252                                  ;push qword 0
   253                                  ;push qword 0
   254                                  ;movupd     [rsp], xmm12
   255                                  ;push qword 0
   256                                  ;push qword 0
   257                                  ;movupd     [rsp], xmm11
   258                                  ;push qword 0
   259                                  ;push qword 0
   260                                  ;movupd     [rsp], xmm10
   261                                  ;push qword 0
   262                                  ;push qword 0
   263                                  ;movupd     [rsp], xmm9
   264                                  ;push qword 0
   265                                  ;push qword 0
   266                                  ;movupd     [rsp], xmm8
   267                                  ;push qword 0
   268                                  ;push qword 0
   269                                  ;movupd     [rsp], xmm7
   270                                  ;push qword 0
   271                                  ;push qword 0
   272                                  ;movupd     [rsp], xmm6
   273                                  ;push qword 0
   274                                  ;push qword 0
   275                                  ;movupd     [rsp], xmm5
   276                                  ;push qword 0
   277                                  ;push qword 0
   278                                  ;movupd     [rsp], xmm4
   279                                  ;push qword 0
   280                                  ;push qword 0
   281                                  ;movupd     [rsp], xmm3
   282                                  ;push qword 0
   283                                  ;push qword 0
   284                                  ;movupd     [rsp], xmm2
   285                                  ;push qword 0
   286                                  ;push qword 0
   287                                  ;movupd     [rsp], xmm1
   288                                  ;push qword 0
   289                                  ;push qword 0
   290                                  ;movupd     [rsp], xmm0
   291                                  ;===== End of back up of SSE2 registers ===============================================================================================
   292                                  
   293                                  ;===== State of the integer stack after backing up SSE ====================================================================================================
   294                                  
   295                                  ;              |---------------------------|
   296                                  ;     rsp+50*8 | arbitrary number from user|
   297                                  ;              |---------------------------|
   298                                  ;     rsp+49*8 | return address            |
   299                                  ;              |---------------------------|
   300                                  ;     rsp+48*8 | rsp                       | <== Contains a value 16 too small.
   301                                  ;              |---------------------------|
   302                                  ;     rsp+47*8 | rax                       |
   303                                  ;              |---------------------------|
   304                                  ;     rsp+46*8 | rbp                       |
   305                                  ;              |---------------------------|
   306                                  ;     rsp+45*8 | rdi                       |
   307                                  ;              |---------------------------|
   308                                  ;     rsp+44*8 | rsi                       |
   309                                  ;              |---------------------------|
   310                                  ;     rsp+43*8 | rdx                       |
   311                                  ;              |---------------------------|
   312                                  ;     rsp+42*8 | rcx                       |
   313                                  ;              |---------------------------|
   314                                  ;     rsp+41*8 | r8                        |
   315                                  ;              |---------------------------|
   316                                  ;     rsp+40*8 | r9                        |
   317                                  ;              |---------------------------|
   318                                  ;     rsp+39*8 | r10                       |
   319                                  ;              |---------------------------|
   320                                  ;     rsp+38*8 | r11                       |
   321                                  ;              |---------------------------|
   322                                  ;     rsp+37*8 | r12                       |
   323                                  ;              |---------------------------|
   324                                  ;     rsp+36*8 | r13                       |
   325                                  ;              |---------------------------|
   326                                  ;     rsp+35*8 | r14                       |
   327                                  ;              |---------------------------|
   328                                  ;     rsp+34*8 | r15                       |
   329                                  ;              |---------------------------|
   330                                  ;     rsp+33*8 | rbx                       |
   331                                  ;              |---------------------------|
   332                                  ;     rsp+32*8 | rflags                    |
   333                                  ;              |---------------------------|
   334                                  ;     rsp+31*8 | xmm15[127-64]             |
   335                                  ;              |---------------------------|
   336                                  ;     rsp+30*8 | xmm15[63-0]               |
   337                                  ;              |---------------------------|
   338                                  ;     rsp+29*8 | xmm14[127-64]             |
   339                                  ;              |---------------------------|
   340                                  ;     rsp+28*8 | xmm14[63-0]               |
   341                                  ;              |---------------------------|
   342                                  ;     rsp+27*8 | xmm13[127-64]             |
   343                                  ;              |---------------------------|
   344                                  ;     rsp+26*8 | xmm13[63-0]               |
   345                                  ;              |---------------------------|
   346                                  ;     rsp+25*8 | xmm12[127-64]             |
   347                                  ;              |---------------------------|
   348                                  ;     rsp+24*8 | xmm12[63-0]               |
   349                                  ;              |---------------------------|
   350                                  ;     rsp+23*8 | xmm11[127-64]             |
   351                                  ;              |---------------------------|
   352                                  ;     rsp+22*8 | xmm11[63-0]               |
   353                                  ;              |---------------------------|
   354                                  ;     rsp+21*8 | xmm10[127-64]             |
   355                                  ;              |---------------------------|
   356                                  ;     rsp+20*8 | xmm10[63-0]               |
   357                                  ;              |---------------------------|
   358                                  ;     rsp+19*8 | xmm9[127-64]              |
   359                                  ;              |---------------------------|
   360                                  ;     rsp+18*8 | xmm9[63-0]                |
   361                                  ;              |---------------------------|
   362                                  ;     rsp+17*8 | xmm8[127-64]              |
   363                                  ;              |---------------------------|
   364                                  ;     rsp+16*8 | xmm8[63-0]                |
   365                                  ;              |---------------------------|
   366                                  ;     rsp+15*8 | xmm7[127-64]              |
   367                                  ;              |---------------------------|
   368                                  ;     rsp+14*8 | xmm7[63-0]                |
   369                                  ;              |---------------------------|
   370                                  ;     rsp+13*8 | xmm6[127-64]              |
   371                                  ;              |---------------------------|
   372                                  ;     rsp+12*8 | xmm6[63-0]                |
   373                                  ;              |---------------------------|
   374                                  ;     rsp+11*8 | xmm5[127-64]              |
   375                                  ;              |---------------------------|
   376                                  ;     rsp+10*8 | xmm5[63-0]                |
   377                                  ;              |---------------------------|
   378                                  ;     rsp+9*8  | xmm4[127-64]              |
   379                                  ;              |---------------------------|
   380                                  ;     rsp+8*8  | xmm4[63-0]                |
   381                                  ;              |---------------------------|
   382                                  ;     rsp+7*8  | xmm3[127-64]              |
   383                                  ;              |---------------------------|
   384                                  ;     rsp+6*8  | xmm3[63-0]                |
   385                                  ;              |---------------------------|
   386                                  ;     rsp+5*8  | xmm2[127-64]              |
   387                                  ;              |---------------------------|
   388                                  ;     rsp+4*8  | xmm2[63-0]                |
   389                                  ;              |---------------------------|
   390                                  ;     rsp+3*8  | xmm1[127-64]              |
   391                                  ;              |---------------------------|
   392                                  ;     rsp+2*8  | xmm1[63-0]                |
   393                                  ;              |---------------------------|
   394                                  ;     rsp+1*8  | xmm0[127-64]              |
   395                                  ;              |---------------------------|
   396                                  ;     rsp+0*8  | xmm0[63-0]                |
   397                                  ;              |---------------------------|
   398                                  
   399                                  
   400                                  
   401                                  
   402                                  
   403                                  
   404                                  ;===== Output the header and four registers ===============================================================================================
   405                                  
   406                                  ;First part of the CCC-64 protocol setup: 4 pushes in order right to left
   407 0000002D 488B842480000000        mov        rax, [rsp+16*8]                                  ;The value in rax is off by 16
   408 00000035 4883C010                add        rax, 16
   409 00000039 50                      push qword rax                                              ;The value of rsp when this subprogram was called is on top of the stack
   410 0000003A 488B6C2478              mov  qword rbp, [rsp+14*8+8]                                ;Obtain the original value of rbp; add +8 due to one push since rbp was placed on the stack
   411 0000003F 55                      push qword rbp
   412 00000040 488B7C2478              mov  qword rdi, [rsp+13*8+16]                               ;Obtain the original value of rdi; add +16 due to two pushes since rdi was placed on the stack
   413 00000045 57                      push qword rdi
   414 00000046 488B742478              mov  qword rsi, [rsp+12*8+24]                               ;Obtain the original value of rsi; add +24 due to 3 pushes since rsi was place on the stack
   415 0000004B 56                      push qword rsi
   416                                  
   417                                  ;===== State of the integer stack after the last 4 pushes =================================================================================
   418                                  
   419                                  ;              |---------------------------|
   420                                  ;     rsp+22*8 | arbitrary number from user|
   421                                  ;              |---------------------------|
   422                                  ;     rsp+21*8 | return address            |
   423                                  ;              |---------------------------|
   424                                  ;     rsp+20*8 | rsp                       | <== Contains a value 16 too small: 1 push (8 bytes) and 1 call (8 bytes) have occurred.
   425                                  ;              |---------------------------|
   426                                  ;     rsp+19*8 | rax                       |
   427                                  ;              |---------------------------|
   428                                  ;     rsp+18*8 | rbp                       |
   429                                  ;              |---------------------------|
   430                                  ;     rsp+17*8 | rdi                       |
   431                                  ;              |---------------------------|
   432                                  ;     rsp+16*8 | rsi                       |
   433                                  ;              |---------------------------|
   434                                  ;     rsp+15*8 | rdx                       |
   435                                  ;              |---------------------------|
   436                                  ;     rsp+14*8 | rcx                       |
   437                                  ;              |---------------------------|
   438                                  ;     rsp+13*8 | r8                        |
   439                                  ;              |---------------------------|
   440                                  ;     rsp+12*8 | r9                        |
   441                                  ;              |---------------------------|
   442                                  ;     rsp+11*8 | r10                       |
   443                                  ;              |---------------------------|
   444                                  ;     rsp+10*8 | r11                       |
   445                                  ;              |---------------------------|
   446                                  ;     rsp+9*8  | r12                       |
   447                                  ;              |---------------------------|
   448                                  ;     rsp+8*8  | r13                       |
   449                                  ;              |---------------------------|
   450                                  ;     rsp+7*8  | r14                       |
   451                                  ;              |---------------------------|
   452                                  ;     rsp+6*8  | r15                       |
   453                                  ;              |---------------------------|
   454                                  ;     rsp+5*8  | rbx                       |
   455                                  ;              |---------------------------|
   456                                  ;     rsp+4*8  | rflags                    |
   457                                  ;              |---------------------------|
   458                                  ;     rsp+3*8  | rsp at time of call       | <== This is the value in rsp immediately before showregisters was invoked.
   459                                  ;              |---------------------------|
   460                                  ;     rsp+2*8  | rbp                       |
   461                                  ;              |---------------------------|
   462                                  ;     rsp+1*8  | rdi                       |
   463                                  ;              |---------------------------|
   464                                  ;     rsp+0    | rsi                       |
   465                                  ;              |---------------------------| 
   466                                  
   467                                  ;Second part of the CCC-64 protocol setup
   468 0000004C 4C8B4C2478              mov qword r9, [rsp+15*8]                                    ;Obtain the original value of rdx
   469 00000051 4C8B442470              mov qword r8, [rsp+14*8]                                    ;Obtain the original value of rcx
   470 00000056 488B4C2428              mov qword rcx, [rsp+5*8]                                    ;Obtain the original value of rbx
   471 0000005B 488B942498000000        mov qword rdx, [rsp+19*8]                                   ;Obtain the original value of rax
   472 00000063 488BB424B0000000        mov qword rsi, [rsp+22*qwordsize]                           ;Obtain the arbitrary marker number entered by the user.
   473 0000006B 48BF-                   mov qword rdi, registerformat1
   474 0000006D [0000000000000000] 
   475                                  
   476                                  ;Third part of the CCC-64 protocol setup
   477 00000075 B800000000              mov qword rax, 0                                            ;Zero in rax indicates that no data from SSE will be sent to printf
   478 0000007A E8(00000000)            call printf                                                 ;Dangerous: printf often changes registers such as r10, r11, etc
   479                                  
   480                                  ;Reverse the four recent pushes
   481 0000007F 5E                      pop rsi
   482 00000080 5F                      pop rdi
   483 00000081 5D                      pop rbp
   484 00000082 4883C408                add rsp, 8                                                  ;This is a pop 8 bytes and discard operation.
   485                                  
   486                                  ;The amount of damage possibly done by printf is unknown.  Therefore, restore all possible values.
   487 00000086 9D                      popf                                                        ;Restore values to rflags
   488 00000087 9C                      pushf                                                       ;Put a copy of rflags directly back to the stack
   489 00000088 488B5C2408              mov rbx,    [rsp+1*8]
   490 0000008D 4C8B7C2410              mov r15,    [rsp+2*8]
   491 00000092 4C8B742418              mov r14,    [rsp+3*8]
   492 00000097 4C8B6C2420              mov r13,    [rsp+4*8]
   493 0000009C 4C8B642428              mov r12,    [rsp+5*8]
   494 000000A1 4C8B5C2430              mov r11,    [rsp+6*8]
   495 000000A6 4C8B542438              mov r10,    [rsp+7*8]
   496 000000AB 4C8B4C2440              mov r9,     [rsp+8*8]
   497 000000B0 4C8B442448              mov r8,     [rsp+9*8]
   498 000000B5 488B4C2450              mov rcx,    [rsp+10*8]
   499 000000BA 488B542458              mov rdx,    [rsp+11*8]
   500 000000BF 488B742460              mov rsi,    [rsp+12*8]
   501 000000C4 488B7C2468              mov rdi,    [rsp+13*8]
   502 000000C9 488B6C2470              mov rbp,    [rsp+14*8]
   503 000000CE 488B442478              mov rax,    [rsp+15*8]
   504                                  
   505                                  ;===== Output the fourth and fifth lines of the register dump =============================================================================
   506                                  
   507                                  ;First part of CCC-64 protocol setup: 3 pushes of parameters from right to left
   508 000000D3 4157                    push qword r15
   509 000000D5 4156                    push qword r14
   510 000000D7 4155                    push qword r13
   511                                  
   512                                  ;Second part of CCC-64 protocol setup: assign parameters in this case from left to right
   513 000000D9 48BF-                   mov qword rdi, registerformat2
   514 000000DB [7D00000000000000] 
   515 000000E3 4C89C6                  mov qword rsi, r8
   516 000000E6 4C89CA                  mov qword rdx, r9
   517 000000E9 4C89D1                  mov qword rcx, r10
   518 000000EC 4D89D8                  mov qword r8, r11
   519 000000EF 4D89E1                  mov qword r9, r12
   520                                  
   521                                  ;Third part of CCC-64 protocol
   522 000000F2 B800000000              mov qword rax, 0
   523 000000F7 E8(00000000)            call printf                                                 ;Dangerous: printf often changes registers such as r10, r11, etc
   524                                  
   525                                  ;Reverse the three recent pushes
   526 000000FC 415D                    pop r13
   527 000000FE 415E                    pop r14
   528 00000100 415F                    pop r15
   529                                  
   530                                  ;The amount of damage possibly done by printf is unknown.  Therefore, take no chances by restoring all possible values.
   531 00000102 9D                      popf                                                        ;Restore values to rflags
   532 00000103 9C                      pushf                                                       ;Put a copy of rflags directly back to the stack.
   533 00000104 488B5C2408              mov rbx,    [rsp+1*8]
   534 00000109 4C8B7C2410              mov r15,    [rsp+2*8]
   535 0000010E 4C8B742418              mov r14,    [rsp+3*8]
   536 00000113 4C8B6C2420              mov r13,    [rsp+4*8]
   537 00000118 4C8B642428              mov r12,    [rsp+5*8]
   538 0000011D 4C8B5C2430              mov r11,    [rsp+6*8]
   539 00000122 4C8B542438              mov r10,    [rsp+7*8]
   540 00000127 4C8B4C2440              mov r9,     [rsp+8*8]
   541 0000012C 4C8B442448              mov r8,     [rsp+9*8]
   542 00000131 488B4C2450              mov rcx,    [rsp+10*8]
   543 00000136 488B542458              mov rdx,    [rsp+11*8]
   544 0000013B 488B742460              mov rsi,    [rsp+12*8]
   545 00000140 488B7C2468              mov rdi,    [rsp+13*8]
   546 00000145 488B6C2470              mov rbp,    [rsp+14*8]
   547 0000014A 488B442478              mov rax,    [rsp+15*8]
   548                                  
   549                                  ;===== Output the sixth and seventh lines of the register dump ============================================================================
   550                                  
   551                                  ;At this time the original value of rflags is on top of the stack.
   552                                  
   553                                  ;Go into the stack and get a copy of that original rflags
   554 0000014F 488B1C24                mov qword rbx, [rsp]                                        ;At this time rflags is on top of that stack; now rbx contain a copy of rflags
   555                                  
   556                                  ;First part of CCC-64 protocol setup: do the pushes for the right most parameters
   557                                  ;Begin process to extract the cf bit, which is bit #0 from the right.
   558 00000153 4889D8                  mov rax, rbx                                                ;Place a copy of rflags into rax
   559 00000156 4883E001                and rax, cmask                                              ;rax has all zero bits except possibly position 0.
   560 0000015A 50                      push qword rax                                              ;Count: push #1 of this section
   561                                  
   562                                  ;Begin process to extract the pf bit
   563 0000015B 4889D8                  mov rax, rbx                                                ;Place a new copy of rflags into rax
   564 0000015E 4883E004                and rax, pmask                                              ;rax has all zero bits except possible position 2
   565 00000162 48C1E802                shr rax, 2                                                  ;The pf bit is bit #2 from the right.
   566 00000166 50                      push qword rax                                              ;Count: push #2 of this section
   567                                  
   568                                  ;Begin process to extract the af bit
   569 00000167 4889D8                  mov rax, rbx
   570 0000016A 4883E010                and rax, amask
   571 0000016E 48C1E804                shr rax, 4                                                  ;The af bit is bit #4 from the right.
   572 00000172 50                      push qword rax                                              ;Count: push #3 of this section
   573                                  
   574                                  ;Second part of CCC-64 protocol setup: move data into the five fixed registers acting as parameters
   575                                  
   576                                  ;Begin process to extract the zf bit: the zero bit
   577 00000173 4889D8                  mov rax, rbx
   578 00000176 4883E040                and rax, zmask
   579 0000017A 48C1E806                shr rax, 6
   580 0000017E 4989C1                  mov qword r9, rax                                           ;Parameter #6 of CCC
   581                                  
   582                                  ;Begin process to extract the sf bit: the sign bit
   583 00000181 4889D8                  mov rax, rbx
   584 00000184 482580000000            and rax, smask
   585 0000018A 48C1E807                shr rax, 7
   586 0000018E 4989C0                  mov qword r8, rax                                           ;Parameter #5 of CCC
   587                                  
   588                                  ;Begin process to extract the of bit: the overflow bit
   589 00000191 4889D8                  mov rax, rbx
   590 00000194 482500080000            and rax, omask
   591 0000019A 48C1E80B                shr rax, 11
   592 0000019E 4889C1                  mov qword rcx, rax                                          ;Parameter #4 of CCC
   593                                  
   594                                  ;Copy the original rflags data to rdx
   595 000001A1 4889DA                  mov qword rdx, rbx                                          ;Parameter #3 of CCC
   596                                  ;
   597                                  ;rip is a highly protected register in the sense that it is the only one providing neither read nor write privileges.
   598                                  ;Therefore, the programmer cannot assign a value to rip nor read the value in rip.  The one technique to obtain the
   599                                  ;value stored in rip is to call a subprogram such as this one, showregisterssubprogram.  The call will place a copy 
   600                                  ;of rip on the integer stack.  That value can be retrieved later from the integer stack, and that is what is done 
   601                                  ;here.  That value is the address of the next instruction to execute when the current subprogram returns.
   602                                  
   603                                  ;Copy the rip at the time this subprogram was called; the copy goes into rsi, which is parameter #2 of CCC
   604 000001A4 488BB424A0000000        mov qword rsi, [rsp+20*qwordsize]                           ;20*8=160 bytes; there have been 20 pushes to this point
   605                                  
   606 000001AC 48BF-                   mov qword rdi, registerformat3                              ;Parameter #1 of CCC
   607 000001AE [E600000000000000] 
   608                                  
   609                                  ;Third part of the CCC-64 protocol
   610 000001B6 B800000000              mov qword rax, 0
   611 000001BB E8(00000000)            call printf
   612                                  
   613                                  ;Reverse the three recent pushes.
   614 000001C0 58                      pop rax                                                     ;Discard the qword containing the af bit
   615 000001C1 58                      pop rax                                                     ;Discard the qword containing the pf bit
   616 000001C2 58                      pop rax                                                     ;Discard the qword containing the cf bit
   617                                  
   618                                  ;The most recent call to printf may have changed the values in some registers.  However, this program will soon return to the caller.
   619                                  ;The next step is to restore values to the SSE2 registers.
   620                                  
   621                                  ;========== Restore all the data to the SEE2 registers ===================================================================================
   622                                  
   623                                  ;Caveat: Un-comment the following only after a complete study of the side effects.
   624                                  
   625                                  ;movupd     xmm15, [rsp+30*8]
   626                                  ;movupd     xmm14, [rsp+28*8]
   627                                  ;movupd     xmm13, [rsp+26*8]
   628                                  ;movupd     xmm12, [rsp+24*8]
   629                                  ;movupd     xmm11, [rsp+22*8]
   630                                  ;movupd     xmm10, [rsp+20*8]
   631                                  ;movupd     xmm9,  [rsp+18*8]
   632                                  ;movupd     xmm8,  [rsp+16*8]
   633                                  ;movupd     xmm7,  [rsp+14*8]
   634                                  ;movupd     xmm6,  [rsp+12*8]
   635                                  ;movupd     xmm5,  [rsp+10*8]
   636                                  ;movupd     xmm4,  [rsp+8*8]
   637                                  ;movupd     xmm3,  [rsp+6*8]
   638                                  ;movupd     xmm2,  [rsp+4*8]
   639                                  ;movupd     xmm1,  [rsp+2*8]
   640                                  ;movupd     xmm0,  [rsp+0*8]
   641                                  
   642                                  ;========== End of restoring SEE@ registers ===============================================================================================
   643                                  
   644                                  
   645                                  ;Therefore, the next step is to restore original values to all the registers whose values were saved except rsp.  Be aware that the 
   646                                  ;operation "add rsp, 8" is equivalent to "pop the integer stack and discard the value".
   647                                  
   648                                  
   649                                  ;===== Restore original values to previously backed up registers ==========================================================================
   650 000001C3 9D                      popf                                                        ;Restore rflags
   651 000001C4 5B                      pop rbx                                                     ;Restore rbx
   652 000001C5 415F                    pop r15                                                     ;Restore r15
   653 000001C7 415E                    pop r14                                                     ;Restore r14
   654 000001C9 415D                    pop r13                                                     ;Restore r13
   655 000001CB 415C                    pop r12                                                     ;Restore r12
   656 000001CD 415B                    pop r11                                                     ;Restore r11
   657 000001CF 415A                    pop r10                                                     ;Restore r10
   658 000001D1 4159                    pop r9                                                      ;Restore r9
   659 000001D3 4158                    pop r8                                                      ;Restore r8
   660 000001D5 59                      pop rcx                                                     ;Restore rcx
   661 000001D6 5A                      pop rdx                                                     ;Restore rdx
   662 000001D7 5E                      pop rsi                                                     ;Restore rsi
   663 000001D8 5F                      pop rdi                                                     ;Restore rdi
   664 000001D9 5D                      pop rbp                                                     ;Restore rbp
   665 000001DA 58                      pop rax                                                     ;Restore rax
   666                                  
   667                                  ;The old value of rsp is now on top of the integer stack.  It needs to be removed and discarded from the stack.
   668 000001DB 4883C408                add rsp, 8                                                  ;Discard the value originally pushed by rsp
   669                                  
   670                                  ;It is time to leave this program.
   671                                  ;The instruction "ret n" where n is a positive integer means "pop the stack once to obtain an address X where execution will resume, then
   672                                  ;add n to rsp effectively popping n number of bytes, then resume execution at the address X".
   673 000001DF C20800                  ret 8                                                       ;Return to address on top of stack and add 8 to rsp.
   674                                  
   675                                  ;End of showregisterssubprogram
   676                                  ;
   677                                  ;==========================================================================================================================================
   678                                  ;                             Show Stack Subprogram
   679                                  ;==========================================================================================================================================
   680                                  ;
   681                                  ;Program: showstacksubprogram
   682                                  ;Purpose: Show the current state of the X86-64 stack.
   683                                  ;This program is called by the macro code inside the file debug.inc.
   684                                  ;A program should bring in the debug.inc into an application program via a statement such as
   685                                  ;%include "debug.inc"
   686                                  ;
   687                                  ;File name: debug.asm
   688                                  ;Language: X86-64 Intel syntax
   689                                  ;Usage: CPSC240
   690                                  ;Author: F. Holliday
   691                                  ;Last update: 20130329
   692                                  
   693                                  ;Deficiency:  This program, showstacksubprogram, does not backup SSE2 registers.  This is a known issue and will be fixed as soon as time allows.
   694                                  
   695                                  ;Assemble: nasm -f elf64 -l debug.lis -o debug.o debug.asm
   696                                  ;
   697                                  ;Concerning the two pointers rbp and rsp.  The system stack, sometimes called the integer stack, is a built-in stack of 
   698                                  ;quadwords.  (Don't confuse this stack with the floating point stack.)  The pointer rsp always points to the top of the
   699                                  ;stack.  Use of the pointer rbp is optional.  That means that a programmer may use it or disregard it completely.  The
   700                                  ;most common use of the rbp is to point to the start of a new activation record.  An activation record is created when
   701                                  ;a subprogram is called, and it is destroyed when the subprogram returns.
   702                                  ;
   703                                  ;Important:  This program is built on rbp.  That means this program treats rbp as the top of the stack.  When calling
   704                                  ;this program it requires three parameters: an arbitrary integer, the number of qwords outside of the stack to be
   705                                  ;displayed, and the number of qwords inside the stack to be displayed.  Separator commas are placed after the first
   706                                  ;and second parameters.  Example call:  dumpstack 59, 4, 10
   707                                  
   708                                  ;===== Sample of expected output from this subprogram =====================================================================================
   709                                  
   710                                  ;To view the integer stack using rbp as the top use a statement like the following:
   711                                  ;  dumpstack 20, 2, 6
   712                                  ;The results will be as in the following:
   713                                  
   714                                  ;Stack Dump # 20:  rbp = 00007fff3ab0bba0 rsp = 00007fff3ab0bb50
   715                                  ;Offset    Address           Value
   716                                  ;  +48  00007fff3ab0bbd0  0000000000000000
   717                                  ;  +40  00007fff3ab0bbc8  00000000004006d0
   718                                  ;  +32  00007fff3ab0bbc0  0000000100000000
   719                                  ;  +24  00007fff3ab0bbb8  00007fff3ab0bc88
   720                                  ;  +16  00007fff3ab0bbb0  0000000000000000
   721                                  ;   +8  00007fff3ab0bba8  00007f318baf376d
   722                                  ;   +0  00007fff3ab0bba0  0000000000000000
   723                                  ;   -8  00007fff3ab0bb98  ffffffffffffff9d
   724                                  ;  -16  00007fff3ab0bb90  00007fff3ab0bc80
   725                                  
   726                                  ;To view the integer stack using rsp as the top use a pair of statements like the following:
   727                                  ;  mov rbp, rsp
   728                                  ;  dumpstack 21, 2, 6
   729                                  ;The results will be as in the following example
   730                                  
   731                                  ;Stack Dump # 21:  rbp = 00007fffe8e939b0 rsp = 00007fffe8e939b0
   732                                  ;Offset    Address           Value
   733                                  ;  +48  00007fffe8e939e0  00007fffe8e93a00
   734                                  ;  +40  00007fffe8e939d8  00007fffe8e93a00
   735                                  ;  +32  00007fffe8e939d0  00000000ffffffff
   736                                  ;  +24  00007fffe8e939c8  00007f804ae98000
   737                                  ;  +16  00007fffe8e939c0  0000000000000000
   738                                  ;   +8  00007fffe8e939b8  00000000004004a0
   739                                  ;   +0  00007fffe8e939b0  00000000ffffffff
   740                                  ;   -8  00007fffe8e939a8  00007fffe8e939b0
   741                                  ;  -16  00007fffe8e939a0  00007fffe8e939b0
   742                                  
   743                                  ;To view the contents of an array use a pair of statements like the following:
   744                                  ;  mov rbp, myarray
   745                                  ;  dumpstack 32, 0, 6
   746                                  ;The contents of the array will be displayed in 8-bytes segments as in this example:
   747                                  
   748                                  ;Stack Dump # 32:  rbp = 0000000000602a28 rsp = 00007fffe8e939b0
   749                                  ;Offset    Address           Value
   750                                  ;  +48  0000000000602a58  0000000000000000
   751                                  ;  +40  0000000000602a50  0000000000000000
   752                                  ;  +32  0000000000602a48  0000000000000000
   753                                  ;  +24  0000000000602a40  0000000000000000
   754                                  ;  +16  0000000000602a38  0000000000000000
   755                                  ;   +8  0000000000602a30  0000000000004000
   756                                  ;   +0  0000000000602a28  c90fdaa22168c235
   757                                  
   758                                  ;==========================================================================================================================================
   759                                  
   760                                  ;Set constants via assembler directives
   761                                  %define qwordsize qword 8                                   ;8 bytes
   762                                  
   763                                  extern printf
   764                                  global showstacksubprogram                                  ;This declaration allows the subprogram to be called from outside this file.
   765                                  
   766                                  segment .data                                               ;This segment declares initialized data
   767                                  
   768 00000178 537461636B2044756D-     stackheadformat db "Stack Dump # %d:  ", 
   769 00000181 7020232025643A2020 
   770 0000018A 726270203D20253031-                     db "rbp = %016lx rsp = %016lx", 10, 
   771 00000193 366C7820727370203D-
   772 0000019C 20253031366C780A   
   773 000001A4 4F6666736574202020-                     db "Offset    Address           Value", 10, 0
   774 000001AD 204164647265737320-
   775 000001B6 202020202020202020-
   776 000001BF 2056616C75650A00   
   777                                  
   778 000001C7 252B35642020253031-     stacklineformat db "%+5d  %016lx  %016lx", 10, 0
   779 000001D0 366C78202025303136-
   780 000001D9 6C780A00           
   781                                  
   782                                  segment .bss                                                ;This segment declares uninitialized data
   783                                      ;This segment is empty
   784                                  
   785                                  segment .text                                               ;Executable instructions appear in this segment
   786                                  
   787                                  showstacksubprogram:                                        ;Where execution begins when this program is called.
   788                                  
   789                                  ;===== Backup all the registers that are used in this program =====================================================================
   790 000001E2 55                      push rbp                                                    ;Backup the base pointer
   791 000001E3 57                      push rdi                                                    ;Backup rdi
   792 000001E4 56                      push rsi                                                    ;Backup rsi
   793 000001E5 52                      push rdx                                                    ;Backup rdx
   794 000001E6 51                      push rcx                                                    ;Backup rcx
   795 000001E7 4150                    push r8                                                     ;Backup r8
   796 000001E9 4151                    push r9                                                     ;Backup r9
   797 000001EB 4152                    push r10                                                    ;Backup r10
   798 000001ED 4153                    push r11                                                    ;Backup r11: printf often changes r11
   799 000001EF 4154                    push r12                                                    ;Backup r12
   800 000001F1 4155                    push r13                                                    ;Backup r13
   801 000001F3 4156                    push r14                                                    ;Backup r14
   802 000001F5 53                      push rbx                                                    ;Backup rbx
   803 000001F6 9C                      pushf                                                       ;Backup rflags
   804                                  ;r15 is not used in this subprogram.  rax is intentionally not backed up.
   805                                  
   806                                  ;===== Prepare to output the dump stack header =====================================================================================
   807                                  ;At this time the integer stack has the following structure
   808                                  ;              |---------------------------|
   809                                  ;     rsp+19*8 | rsp                       |
   810                                  ;              |---------------------------|
   811                                  ;     rsp+18*8 | rbp                       |
   812                                  ;              |---------------------------|
   813                                  ;     rsp+17*8 | #qwords inside of stack   |
   814                                  ;              |---------------------------|
   815                                  ;     rsp+16*8 | #qwords outside of stack  |
   816                                  ;              |---------------------------|
   817                                  ;     rsp+15*8 | arbitrary number from user|
   818                                  ;              |---------------------------|
   819                                  ;     rsp+14*8 | return address            |
   820                                  ;              |---------------------------|
   821                                  ;     rsp+13*8 | rbp                       |
   822                                  ;              |---------------------------|
   823                                  ;     rsp+12*8 | rdi                       |
   824                                  ;              |---------------------------|
   825                                  ;     rsp+11*8 | rsi                       |
   826                                  ;              |---------------------------|
   827                                  ;     rsp+10*8 | rdx                       |
   828                                  ;              |---------------------------|
   829                                  ;     rsp+9*8  | rcx                       |
   830                                  ;              |---------------------------|
   831                                  ;     rsp+8*8  | r8                        |
   832                                  ;              |---------------------------|
   833                                  ;     rsp+7*8  | r9                        |
   834                                  ;              |---------------------------|
   835                                  ;     rsp+6*8  | r10                       |
   836                                  ;              |---------------------------|
   837                                  ;     rsp+5*8  | r11                       |
   838                                  ;              |---------------------------|
   839                                  ;     rsp+4*8  | r12                       |
   840                                  ;              |---------------------------|
   841                                  ;     rsp+3*8  | r13                       |
   842                                  ;              |---------------------------|
   843                                  ;     rsp+2*8  | r14                       |
   844                                  ;              |---------------------------|
   845                                  ;     rsp+1*8  | rbx                       |
   846                                  ;              |---------------------------|
   847                                  ;     rsp+0    | rflags                    |
   848                                  ;              |---------------------------|
   849                                  
   850                                  ;===== Output the header prior to displaying the contents of memory =======================================================================
   851                                  ;Assign values to be passed to printf for outputting the dump stack header
   852 000001F7 48BF-                   mov qword rdi, stackheadformat                              ;The format of the header
   853 000001F9 [7801000000000000] 
   854 00000201 488B742478              mov qword rsi, [rsp+15*8]                                   ;Arbitrary number passed in from caller
   855 00000206 488B942490000000        mov qword rdx, [rsp+18*8]                                   ;Retrieve the value of rbp
   856 0000020E 488B8C2498000000        mov qword rcx, [rsp+19*8]                                   ;Retrieve the value of rsp
   857 00000216 B800000000              mov qword rax, 0                                            ;Zero in rax signals to printf that no vector registers (xmm) are used.
   858 0000021B E8(00000000)            call printf
   859                                  
   860                                  ;===== Set up conditions before entering a loop ===========================================================================================
   861                                  ;Retrieve from the stack the number of qwords within the stack to be displayed
   862 00000220 4C8BAC2488000000        mov qword r13, [rsp+17*8]                                   ;r13 will serve as loop counter variable
   863                                  ;Retrieve from the stack the number of qwords outside the stack to be displayed
   864 00000228 4C8BB42480000000        mov qword r14, [rsp+16*8]                                   ;r14 will help define the loop termination condition
   865 00000230 49F7DE                  neg r14                                                     ;Negate r14.  Now r14 contains a negative integer
   866                                  
   867                                  ;Setup rbx as offset number that will appear in the first column of output.
   868 00000233 488B842488000000        mov qword rax, [rsp+17*8]                                   ;Retrieve from the stack the number of qwords within the stack to be displayed.
   869 0000023B 41BC08000000            mov qword r12, 8                                            ;Temporarily store 8 in r12
   870 00000241 49F7E4                  mul r12                                                     ;Multiply rax by 8 bytes per qword
   871 00000244 4889C3                  mov qword rbx, rax                                          ;Save the product in rbx (column 1 of output)
   872                                  
   873                                  ;Retrieve from the stack the original value of rbp; r12 will be the address that appears in the 2nd column of output.
   874 00000247 4C8BA42490000000        mov qword r12, [rsp+18*8]                                   ;Copy rbp to r12
   875 0000024F 4901DC                  add r12, rbx                                                ;Give r12 the first address to be display in column 2 of the output.
   876                                  
   877                                  beginloop:
   878                                  
   879                                  ;===== Prepare to output one line of the body of the stack dump ===========================================================================
   880                                  ;Follow the CCC-64 protocol
   881 00000252 48BF-                   mov       rdi, stacklineformat                              ;Format for offset, address, and quadword value
   882 00000254 [C701000000000000] 
   883 0000025C 4889DE                  mov qword rsi, rbx                                          ;rbx stores the offset value
   884 0000025F 4C89E2                  mov qword rdx, r12                                          ;r12 stores the address to be displayed
   885 00000262 488B0A                  mov qword rcx, [rdx]                                        ;rcx receives the contents of memory at rbp+40
   886 00000265 B800000000              mov qword rax, 0                                            ;No vector registers contain data for printf
   887 0000026A E8(00000000)            call printf
   888                                  
   889                                  ;===== Advance the variables 8 bytes in the direction of small addresses ==================================================================
   890                                  
   891 0000026F 4883EB08                sub rbx, 8                                                  ;rbx stores column 1, which is the offset value
   892 00000273 4983EC08                sub r12, 8                                                  ;r12 stores column 2, which is the address value
   893 00000277 49FFCD                  dec r13                                                     ;r13 is loop counter; it decrements from high value to low (possibly negative) value
   894                                  
   895                                  ;===== Check for loop termination condition ===============================================================================================
   896 0000027A 4D39F5                  cmp r13, r14                                                ;Compare loop variable r13 with terminating value r14
   897 0000027D 7DD3                    jge beginloop                                               ;If r13 >= r14 then continue to iterate
   898                                  
   899                                  
   900                                  ;OLD CODE BELOW -- This will eventually be removed
   901                                  
   902                                  ;===== Output the header prior to displaying the contents of memory =======================================================================
   903                                  ;Assign values to be passed to printf for outputting the dump stack header
   904                                  ;mov qword rdi, stackheadformat                              ;The format of the header
   905                                  ;mov qword rsi, [rsp+10*8]                                   ;Arbitrary number passed in from caller
   906                                  ;mov qword rdx, [rsp+13*8]                                   ;Retrieve the value of rbp
   907                                  ;mov qword rcx, [rsp+14*8]                                   ;Retrieve the value of rsp
   908                                  ;mov qword rax, 0                                            ;Zero in rax signals to printf that no vector registers (xmm) are used.
   909                                  ;call printf
   910                                  
   911                                  ;===== Set up conditions before entering a loop ===========================================================================================
   912                                  ;Retrieve from the stack the number of qwords within the stack to be displayed
   913                                  ;mov qword r13, [rsp+12*8]                                   ;r13 will serve as loop counter variable
   914                                  ;Retrieve from the stack the number of qwords outside the stack to be displayed
   915                                  ;mov qword r14, [rsp+11*8]                                   ;r14 will help define the loop termination condition
   916                                  ;neg r14                                                     ;Negate r14.  Now r14 contains a negative integer
   917                                  
   918                                  ;Setup rbx as offset number that will appear in the first column of output.
   919                                  ;mov qword rax, [rsp+12*8]                                   ;Retrieve from the stack the number of qwords within the stack to be displayed.
   920                                  ;mov qword r12, 8                                            ;Temporarily store 8 in r12
   921                                  ;mul r12                                                     ;Multiply rax by 8 bytes per qword
   922                                  ;mov qword rbx, rax                                          ;Save the product in rbx (column 1 of output)
   923                                  
   924                                  ;Retrieve from the stack the original value of rbp; r10 will be the address that appears in the 2nd column of output.
   925                                  ;mov qword r10, [rsp+13*8]                                   ;Copy rbp to r10
   926                                  ;add r10, rbx                                                ;Give r10 the first address to be display in column 2 of the output.
   927                                  
   928                                  ;beginloop:
   929                                  
   930                                  ;===== Prepare to output one line of the body of the stack dump ===========================================================================
   931                                  ;Follow the CCC-64 protocol
   932                                  ;mov       rdi, stacklineformat                              ;Format for offset, address, and quadword value
   933                                  ;mov qword rsi, rbx                                          ;rbx stores the offset value
   934                                  ;mov qword rdx, r10                                          ;r10 stores the address to be displayed
   935                                  ;mov qword rcx, [rdx]                                        ;rcx receives the contents of memory at rbp+40
   936                                  ;mov qword rax, 0                                            ;No vector registers contain data for printf
   937                                  ;call printf
   938                                  
   939                                  ;===== Advance the variables 8 bytes in the direction of small addresses ==================================================================
   940                                  
   941                                  ;sub rbx, 8                                                  ;rbx stores column 1, which is the offset value
   942                                  ;sub r10, 8                                                  ;r10 stores column 2, which is the address value
   943                                  ;dec r13                                                     ;r13 is loop counter; it decrements from high value to low (possibly negative) value
   944                                  
   945                                  ;===== Check for loop termination condition ===============================================================================================
   946                                  ;cmp r13, r14                                                ;Compare loop variable r13 with terminating value r14
   947                                  ;jge beginloop                                               ;If r13 >= r14 then continue to iterate
   948                                  
   949                                  
   950                                  ;END OLD CODE -- End of old stuff that will be removed.
   951                                  
   952                                  
   953                                  ;===== Restore original values to integer registers =======================================================================================
   954                                  
   955 0000027F 9D                      popf                                                        ;Restore rflags
   956 00000280 5B                      pop rbx                                                     ;Restore rbx
   957 00000281 415E                    pop r14                                                     ;Restore r14
   958 00000283 415D                    pop r13                                                     ;Restore r13
   959 00000285 415C                    pop r12                                                     ;Restore r12
   960 00000287 415B                    pop r11                                                     ;Restore r11
   961 00000289 415A                    pop r10                                                     ;Restore r10
   962 0000028B 4159                    pop r9                                                      ;Restore r9
   963 0000028D 4158                    pop r8                                                      ;Restore r8
   964 0000028F 59                      pop rcx                                                     ;Restore rcx
   965 00000290 5A                      pop rdx                                                     ;Restore rdx
   966 00000291 5E                      pop rsi                                                     ;Restore rsi
   967 00000292 5F                      pop rdi                                                     ;Restore rdi
   968 00000293 5D                      pop rbp                                                     ;Restore rbp
   969                                  
   970                                  ;Now the number of 8-byte pushes equals the number of 8-byte pops.
   971                                  ;
   972                                  ;It is time to leave this program.
   973 00000294 C22800                  ret 40                                                      ;Return to address on top of stack and add 5*8 to rsp.
   974                                  ;End of showstacksubprogram
   975                                  
   976                                  ;==========================================================================================================================================
   977                                  ;                             Show FPU registers subprogram
   978                                  ;==========================================================================================================================================
   979                                  ;
   980                                  ;Program: showfpusubprogram
   981                                  ;Purpose: Show the current state of the FPU87 stack of registers.  Each member of the stack is an individual 10-bytes register in FPU87 
   982                                  ;extended format.
   983                                  ;This program is called by the macro code inside the file debug.inc.
   984                                  ;A program should bring in the debug.inc into an application program via a statement such as
   985                                  ;%include "debug.inc"
   986                                  ;
   987                                  ;File name: debug.asm
   988                                  ;Language: X86-64
   989                                  ;Usage: CPSC240
   990                                  ;Author: F. Holliday
   991                                  ;Last update: 2012-April-27
   992                                  
   993                                  ;Credit: The concepts for this program "showfpusubprogram" originated with a similar program written by Dr Paul Carter, and posted at the
   994                                  ;website www.drpaulcarter.com/pcasm .  His original program is somewhat more sophisticated than this one; for example, to allocate space on
   995                                  ;the integer stack he does not perform 14 individual pushes of one quadword per push.  He uses more advanced techniques to accomplish his 
   996                                  ;goals, and thereby needs fewer instructions.  Nevertheless, this program implements much of his original work using simpler and more 
   997                                  ;tedious programming techniques.
   998                                  
   999                                  ;Deficiency:  This program, showfpusubprogram, does not backup SSE2 registers.  This is a known issue and will be fixed as soon as time allows.
  1000                                  
  1001                                  ;Assemble: nasm -f elf64 -l debug.lis -o debug.o debug.asm
  1002                                  
  1003                                  ;Give a name to a famous number via assembler directive
  1004                                  %define qwordsize 8                                         ;8 bytes
  1005                                  
  1006                                  ;Set masks for Control Word via assembler directives
  1007                                  %define xcontrol 0000000000001000h                          ;bit #12
  1008                                  %define rcontrol 0000000000000c00h                          ;bits #10-11
  1009                                  %define pcontrol 0000000000000300h                          ;bits #8-9
  1010                                  %define pmask    0000000000000020h                          ;bit #5
  1011                                  %define umask    0000000000000010h                          ;bit #4
  1012                                  %define omask    0000000000000008h                          ;bit #3
  1013                                  %define zmask    0000000000000004h                          ;bit #2
  1014                                  %define dmask    0000000000000002h                          ;bit #1
  1015                                  %define imask    0000000000000001h                          ;bit #0 
  1016                                  
  1017                                  ;Set masks for Status Word via assembler directives
  1018                                  %define iemask 0000000000000001h                            ;bit #0
  1019                                  %define demask 0000000000000002h                            ;bit #1
  1020                                  %define zemask 0000000000000004h                            ;bit #2
  1021                                  %define oemask 0000000000000008h                            ;bit #3
  1022                                  %define uemask 0000000000000010h                            ;bit #4
  1023                                  %define pemask 0000000000000020h                            ;bit #5
  1024                                  %define sfmask 0000000000000040h                            ;bit #6
  1025                                  %define esmask 0000000000000080h                            ;bit #7
  1026                                  %define c0mask 0000000000000100h                            ;bit #8
  1027                                  %define c1mask 0000000000000200h                            ;bit #9
  1028                                  %define c2mask 0000000000000400h                            ;bit #10
  1029                                  %define tpmask 0000000000003800h                            ;bits #11-13
  1030                                  %define c3mask 0000000000004000h                            ;bit #14
  1031                                  %define bmask  0000000000008000h                            ;bit #15
  1032                                  
  1033                                  ;Set masks for the Tag Word via assembler directives
  1034                                  %define tag7mask 000000000000c000h                          ;bits #14-15
  1035                                  %define tag6mask 0000000000003000h                          ;bits #12-13
  1036                                  %define tag5mask 0000000000000c00h                          ;bits #10-11
  1037                                  %define tag4mask 0000000000000300h                          ;bits #8-9
  1038                                  %define tag3mask 00000000000000c0h                          ;bits #6-7
  1039                                  %define tag2mask 0000000000000030h                          ;bits #4-5
  1040                                  %define tag1mask 000000000000000ch                          ;bits #2-3
  1041                                  %define tag0mask 0000000000000003h                          ;bits #0-1
  1042                                  
  1043                                  extern printf
  1044                                  
  1045                                  segment .data                                               ;This segment declares initialized data
  1046                                  
  1047 000001DD 0A5838372046505520-     x87headformat db 10, "X87 FPU Display #%d", 10, "Control Word = %.4x Status Word = %.4x Tag Word = %.4x", 10, 0
  1048 000001E6 446973706C61792023-
  1049 000001EF 25640A436F6E74726F-
  1050 000001F8 6C20576F7264203D20-
  1051 00000201 252E34782053746174-
  1052 0000020A 757320576F7264203D-
  1053 00000213 20252E347820546167-
  1054 0000021C 20576F7264203D2025-
  1055 00000225 2E34780A00         
  1056 0000022A 257300                  stringformat db "%s", 0
  1057 0000022D 526567697374657220-     columnheadings db "Register Extended hex number   Tag", 10, 0
  1058 00000236 457874656E64656420-
  1059 0000023F 686578206E756D6265-
  1060 00000248 722020205461670A00 
  1061 00000251 202073743720202020-     st7format db "  st7    %04x%016lx  %s", 10, 0
  1062 0000025A 25303478253031366C-
  1063 00000263 78202025730A00     
  1064 0000026A 202073743620202020-     st6format db "  st6    %04x%016lx  %s", 10, 0
  1065 00000273 25303478253031366C-
  1066 0000027C 78202025730A00     
  1067 00000283 202073743520202020-     st5format db "  st5    %04x%016lx  %s", 10, 0
  1068 0000028C 25303478253031366C-
  1069 00000295 78202025730A00     
  1070 0000029C 202073743420202020-     st4format db "  st4    %04x%016lx  %s", 10, 0
  1071 000002A5 25303478253031366C-
  1072 000002AE 78202025730A00     
  1073 000002B5 202073743320202020-     st3format db "  st3    %04x%016lx  %s", 10, 0
  1074 000002BE 25303478253031366C-
  1075 000002C7 78202025730A00     
  1076 000002CE 202073743220202020-     st2format db "  st2    %04x%016lx  %s", 10, 0
  1077 000002D7 25303478253031366C-
  1078 000002E0 78202025730A00     
  1079 000002E7 202073743120202020-     st1format db "  st1    %04x%016lx  %s", 10, 0
  1080 000002F0 25303478253031366C-
  1081 000002F9 78202025730A00     
  1082 00000300 202073743020202020-     st0format db "  st0    %04x%016lx  %s", 10, 0
  1083 00000309 25303478253031366C-
  1084 00000312 78202025730A00     
  1085                                  ;
  1086 00000319 456D707479206F7220-     emptyspace db "Empty or Free space", 0
  1087 00000322 467265652073706163-
  1088 0000032B 6500               
  1089 0000032D 56616C6964206E756D-     validnumber db "Valid number", 0
  1090 00000336 62657200           
  1091 0000033A 5A65726F206E756D62-     floatingpointzero db "Zero number", 0
  1092 00000343 657200             
  1093 00000346 5370656369616C3A20-     specialnumber db "Special: denormal, infinity, or nan", 0
  1094 0000034F 64656E6F726D616C2C-
  1095 00000358 20696E66696E697479-
  1096 00000361 2C206F72206E616E00 
  1097 0000036A 0A00                    newline db 10, 0 ;temporary
  1098                                  ;
  1099                                  ;Information about the FPU Control Word was obtained from http://www.c-jump.com/CIS77/reference/Intel/CIS77_24319002/index.html ==> Section 7.3.4
  1100 0000036C 436F6E74726F6C2077-     controlwordheading db "Control word by individual components:", 10, "Bit# Value Mnemonic Description", 10, 0
  1101 00000375 6F726420627920696E-
  1102 0000037E 646976696475616C20-
  1103 00000387 636F6D706F6E656E74-
  1104 00000390 733A0A426974232056-
  1105 00000399 616C7565204D6E656D-
  1106 000003A2 6F6E69632044657363-
  1107 000003AB 72697074696F6E0A00 
  1108 000003B4 31332D313520202D20-     controlwordbit15_13 db "13-15  -     --     Unused", 10, 0
  1109 000003BD 202020202D2D202020-
  1110 000003C6 2020556E757365640A-
  1111 000003CF 00                 
  1112 000003D0 203132202020202530-     controlwordbit12 db " 12    %01x     X      Infinity control", 10, 0
  1113 000003D9 317820202020205820-
  1114 000003E2 2020202020496E6669-
  1115 000003EB 6E69747920636F6E74-
  1116 000003F4 726F6C0A00         
  1117 000003F9 31302D313120202530-     controlwordbit11_10 db "10-11  %01x     RC     Rounding control", 10, 0
  1118 00000402 317820202020205243-
  1119 0000040B 2020202020526F756E-
  1120 00000414 64696E6720636F6E74-
  1121 0000041D 726F6C0A00         
  1122 00000422 20382D392020202530-     controlwordbit9_8 db " 8-9   %01x     PC     Precision control", 10, 0
  1123 0000042B 317820202020205043-
  1124 00000434 202020202050726563-
  1125 0000043D 6973696F6E20636F6E-
  1126 00000446 74726F6C0A00       
  1127 0000044C 20362D372020202D20-     controlwordbit7_6 db " 6-7   -     --     Unused", 10, 0
  1128 00000455 202020202D2D202020-
  1129 0000045E 2020556E757365640A-
  1130 00000467 00                 
  1131 00000468 202035202020202530-     controlwordbit5 db "  5    %01x     PM     Precision mask", 10, 0
  1132 00000471 31782020202020504D-
  1133 0000047A 202020202050726563-
  1134 00000483 6973696F6E206D6173-
  1135 0000048C 6B0A00             
  1136 0000048F 202034202020202530-     controlwordbit4 db "  4    %01x     UM     Underflow mask", 10, 0
  1137 00000498 31782020202020554D-
  1138 000004A1 2020202020556E6465-
  1139 000004AA 72666C6F77206D6173-
  1140 000004B3 6B0A00             
  1141 000004B6 202033202020202530-     controlwordbit3 db "  3    %01x     OM     Overflow mask", 10, 0
  1142 000004BF 317820202020204F4D-
  1143 000004C8 20202020204F766572-
  1144 000004D1 666C6F77206D61736B-
  1145 000004DA 0A00               
  1146 000004DC 202032202020202530-     controlwordbit2 db "  2    %01x     ZM     Zero divide mask", 10, 0
  1147 000004E5 317820202020205A4D-
  1148 000004EE 20202020205A65726F-
  1149 000004F7 20646976696465206D-
  1150 00000500 61736B0A00         
  1151 00000505 202031202020202530-     controlwordbit1 db "  1    %01x     DM     Denormalized operand mask", 10, 0
  1152 0000050E 31782020202020444D-
  1153 00000517 202020202044656E6F-
  1154 00000520 726D616C697A656420-
  1155 00000529 6F706572616E64206D-
  1156 00000532 61736B0A00         
  1157 00000537 202030202020202530-     controlwordbit0 db "  0    %01x     IM     Invalid operation mask", 10, 0            
  1158 00000540 31782020202020494D-
  1159 00000549 2020202020496E7661-
  1160 00000552 6C6964206F70657261-
  1161 0000055B 74696F6E206D61736B-
  1162 00000564 0A00               
  1163                                  
  1164                                  ;Reference regarding FPU Status Word: Plantz (2012), Table 14.4, page 355.
  1165 00000566 53746174757320776F-     statuswordheading db "Status word by individual bits (Plantz, page 355):", 10, "Bit# Value Mnemonic Description", 10, 0
  1166 0000056F 726420627920696E64-
  1167 00000578 6976696475616C2062-
  1168 00000581 6974732028506C616E-
  1169 0000058A 747A2C207061676520-
  1170 00000593 333535293A0A426974-
  1171 0000059C 232056616C7565204D-
  1172 000005A5 6E656D6F6E69632044-
  1173 000005AE 65736372697074696F-
  1174 000005B7 6E0A00             
  1175 000005BA 202030202020202530-     statuswordbit0 db "  0    %01x     IE     Invalid operation", 10, 0
  1176 000005C3 317820202020204945-
  1177 000005CC 2020202020496E7661-
  1178 000005D5 6C6964206F70657261-
  1179 000005DE 74696F6E0A00       
  1180 000005E4 202031202020202530-     statuswordbit1 db "  1    %01x     DE     Denormalized operation", 10, 0
  1181 000005ED 317820202020204445-
  1182 000005F6 202020202044656E6F-
  1183 000005FF 726D616C697A656420-
  1184 00000608 6F7065726174696F6E-
  1185 00000611 0A00               
  1186 00000613 202032202020202530-     statuswordbit2 db "  2    %01x     ZE     Zero divide", 10, 0
  1187 0000061C 317820202020205A45-
  1188 00000625 20202020205A65726F-
  1189 0000062E 206469766964650A00 
  1190 00000637 202033202020202530-     statuswordbit3 db "  3    %01x     OE     Overflow", 10, 0
  1191 00000640 317820202020204F45-
  1192 00000649 20202020204F766572-
  1193 00000652 666C6F770A00       
  1194 00000658 202034202020202530-     statuswordbit4 db "  4    %01x     UE     Underflow", 10, 0
  1195 00000661 317820202020205545-
  1196 0000066A 2020202020556E6465-
  1197 00000673 72666C6F770A00     
  1198 0000067A 202035202020202530-     statuswordbit5 db "  5    %01x     PE     Precision", 10, 0
  1199 00000683 317820202020205045-
  1200 0000068C 202020202050726563-
  1201 00000695 6973696F6E0A00     
  1202 0000069C 202036202020202530-     statuswordbit6 db "  6    %01x     SF     Stack fault", 10, 0
  1203 000006A5 317820202020205346-
  1204 000006AE 202020202053746163-
  1205 000006B7 6B206661756C740A00 
  1206 000006C0 202037202020202530-     statuswordbit7 db "  7    %01x     ES     Error summary status", 10, 0
  1207 000006C9 317820202020204553-
  1208 000006D2 20202020204572726F-
  1209 000006DB 722073756D6D617279-
  1210 000006E4 207374617475730A00 
  1211 000006ED 202038202020202530-     statuswordbit8 db "  8    %01x     C0     Condition code 0", 10, 0
  1212 000006F6 317820202020204330-
  1213 000006FF 2020202020436F6E64-
  1214 00000708 6974696F6E20636F64-
  1215 00000711 6520300A00         
  1216 00000716 202039202020202530-     statuswordbit9 db "  9    %01x     C1     Condition code 1", 10, 0
  1217 0000071F 317820202020204331-
  1218 00000728 2020202020436F6E64-
  1219 00000731 6974696F6E20636F64-
  1220 0000073A 6520310A00         
  1221 0000073F 203130202020202530-     statuswordbit10 db " 10    %01x     C2     Condition code 2", 10, 0
  1222 00000748 317820202020204332-
  1223 00000751 2020202020436F6E64-
  1224 0000075A 6974696F6E20636F64-
  1225 00000763 6520320A00         
  1226 00000768 31312D313320202530-     statuswordbit11_13 db "11-13  %01x     TOP    Top of stack", 10, 0
  1227 00000771 31782020202020544F-
  1228 0000077A 5020202020546F7020-
  1229 00000783 6F6620737461636B0A-
  1230 0000078C 00                 
  1231 0000078D 203134202020202530-     statuswordbit14 db " 14    %01x     C3     Condition code 3", 10, 0
  1232 00000796 317820202020204333-
  1233 0000079F 2020202020436F6E64-
  1234 000007A8 6974696F6E20636F64-
  1235 000007B1 6520330A00         
  1236 000007B6 203135202020202530-     statuswordbit15 db " 15    %01x     B      FPU busy", 10, 0
  1237 000007BF 317820202020204220-
  1238 000007C8 202020202046505520-
  1239 000007D1 627573790A00       
  1240                                  ;
  1241                                  ;Information about the Tag Word was obtained from http://www.c-jump.com/CIS77/reference/Intel/CIS77_24319002/index.html ==> Section 7.3.6
  1242 000007D7 54616720776F726420-     tagwordheading db "Tag word by individual components each of size 2 bits:", 10,
  1243 000007E0 627920696E64697669-
  1244 000007E9 6475616C20636F6D70-
  1245 000007F2 6F6E656E7473206561-
  1246 000007FB 6368206F662073697A-
  1247 00000804 65203220626974733A-
  1248 0000080D 0A                 
  1249 0000080E 5461672076616C7565-                    db "Tag values: 0=Valid number, 1=Floating point zero, 2=Special number (denormal, infinity, or nan), 3=Empty register (free space)", 10
  1250 00000817 733A20303D56616C69-
  1251 00000820 64206E756D6265722C-
  1252 00000829 20313D466C6F617469-
  1253 00000832 6E6720706F696E7420-
  1254 0000083B 7A65726F2C20323D53-
  1255 00000844 70656369616C206E75-
  1256 0000084D 6D626572202864656E-
  1257 00000856 6F726D616C2C20696E-
  1258 0000085F 66696E6974792C206F-
  1259 00000868 72206E616E292C2033-
  1260 00000871 3D456D707479207265-
  1261 0000087A 676973746572202866-
  1262 00000883 726565207370616365-
  1263 0000088C 290A               
  1264 0000088E 426974232056616C75-                    db "Bit# Value   Description", 10, 0
  1265 00000897 652020204465736372-
  1266 000008A0 697074696F6E0A00   
  1267 000008A8 31342D313520202530-     tag7bits15_14 db "14-15  %01x     Tag7", 10, 0
  1268 000008B1 317820202020205461-
  1269 000008BA 67370A00           
  1270 000008BE 31322D313320202530-     tag6bits13_12 db "12-13  %01x     Tag6", 10, 0
  1271 000008C7 317820202020205461-
  1272 000008D0 67360A00           
  1273 000008D4 31302D313120202530-     tag5bits11_10 db "10-11  %01x     Tag5", 10, 0
  1274 000008DD 317820202020205461-
  1275 000008E6 67350A00           
  1276 000008EA 20382D392020202530-     tag4bits9_8 db " 8-9   %01x     Tag4", 10, 0
  1277 000008F3 317820202020205461-
  1278 000008FC 67340A00           
  1279 00000900 20362D372020202530-     tag3bits7_6 db " 6-7   %01x     Tag3", 10, 0
  1280 00000909 317820202020205461-
  1281 00000912 67330A00           
  1282 00000916 20342D352020202530-     tag2bits5_4 db " 4-5   %01x     Tag2", 10, 0
  1283 0000091F 317820202020205461-
  1284 00000928 67320A00           
  1285 0000092C 20322D332020202530-     tag1bits3_2 db " 2-3   %01x     Tag1", 10, 0
  1286 00000935 317820202020205461-
  1287 0000093E 67310A00           
  1288 00000942 20302D312020202530-     tag0bits1_0 db " 0-1   %01x     Tag0", 10, 0
  1289 0000094B 317820202020205461-
  1290 00000954 67300A00           
  1291                                  
  1292 00000958 456E64206F66204650-     farewell db "End of FPU87 stack dump", 10, 0
  1293 00000961 55383720737461636B-
  1294 0000096A 2064756D700A00     
  1295                                  
  1296                                  segment .bss                                                ;This segment declares uninitialized data
  1297                                  ;
  1298                                  segment .text                                               ;This segment contains executable instructions
  1299                                  global showfpusubprogram                                    ;fpu refers to X87FPU also known as the st stack.
  1300                                  
  1301                                  showfpusubprogram:                                          ;A place where execution begins when this program is called.
  1302                                  
  1303                                  ;Safe programming practice: save all the data that may possibly be modified within this subprogram.  Intentionally the registers rsp and 
  1304                                  ;rax are not backed up.
  1305 00000297 55                      push rbp                                                    ;Back up the very important base pointer register
  1306 00000298 57                      push rdi                                                    ;Back up rdi
  1307 00000299 56                      push rsi                                                    ;Back up rsi
  1308 0000029A 52                      push rdx                                                    ;Back up rdx
  1309 0000029B 51                      push rcx                                                    ;Back up rcx
  1310 0000029C 4150                    push r8                                                     ;Back up r8
  1311 0000029E 4151                    push r9                                                     ;Back up r9
  1312 000002A0 4152                    push r10                                                    ;Back up r10
  1313 000002A2 4153                    push r11                                                    ;Back up r11
  1314 000002A4 4154                    push r12                                                    ;Back up r12
  1315 000002A6 4155                    push r13                                                    ;Back up r13
  1316 000002A8 4156                    push r14                                                    ;Back up r14
  1317 000002AA 4157                    push r15                                                    ;Back up r15
  1318 000002AC 53                      push rbx                                                    ;Back up rbx
  1319 000002AD 9C                      pushf                                                       ;Back up rflags
  1320                                  
  1321                                  ;= = = = = = Begin instructions to output X87 FPU = = = = = = = = =
  1322                                  ;
  1323                                  ;108 bytes of free storage is needed to store an image of the FPU.
  1324                                  ;Here we create 112 bytes of storage (14 qwords).
  1325 000002AE B800000000              mov qword rax, 0
  1326 000002B3 50                      push rax  ;push #1
  1327 000002B4 50                      push rax  ;push #2
  1328 000002B5 50                      push rax  ;push #3
  1329 000002B6 50                      push rax  ;push #4
  1330 000002B7 50                      push rax  ;push #5
  1331 000002B8 50                      push rax  ;push #6
  1332 000002B9 50                      push rax  ;push #7
  1333 000002BA 50                      push rax  ;push #8
  1334 000002BB 50                      push rax  ;push #9
  1335 000002BC 50                      push rax  ;push #10
  1336 000002BD 50                      push rax  ;push #11
  1337 000002BE 50                      push rax  ;push #12
  1338 000002BF 50                      push rax  ;push #13
  1339 000002C0 50                      push rax  ;push #14
  1340                                  
  1341                                  ;Place a copy of the entire FPU into the first 108 bytes of storage.
  1342 000002C1 9BDD3424                fsave [rsp]                                       ;There is an alternate command 'fnsave' that is less safe.  Here fsave is used.  After execution of
  1343                                  ;                                                 ;fsave the entire fpu is reset; that is, all data are wiped clean identical to using the finit or
  1344                                  ;                                                 ;the fninit instruction.
  1345                                  
  1346                                  ;Prepare for outputting the header line
  1347 000002C5 48BF-                   mov rdi, x87headformat                            ;Copy the starting address of the format to the first standard parameter, namely: rdi
  1348 000002C7 [DD01000000000000] 
  1349 000002CF 488BB424F0000000        mov qword rsi, [rsp+30*qwordsize]                 ;Copy the identifier number provided by the caller to the second standard parameter, namely: rsi
  1350 000002D7 668B1C24                mov word bx, [rsp]                                ;Retrieve the control word
  1351 000002DB 4881E3FFFF0000          and rbx, 000000000000ffffh                        ;Make sure the high order bits of rbx are zeros; only the low order word is preserved
  1352 000002E2 4889DA                  mov rdx, rbx                                      ;Copy the control word to the third standard parameter, namely: rdx
  1353 000002E5 668B5C2404              mov word bx, [rsp+4]                              ;Get the status word
  1354 000002EA 4881E3FFFF0000          and rbx, 000000000000ffffh                        ;Make sure the high order bits of rbx are zeros; only the low order word is preserved
  1355 000002F1 4889D9                  mov rcx, rbx                                      ;Copy the status word to the fourth standard parameter, namely: rcx
  1356 000002F4 668B5C2408              mov word bx, [rsp+8]                              ;Get the tag word
  1357 000002F9 4881E3FFFF0000          and rbx, 000000000000ffffh                        ;Make sure the high order bits of rbx are zeros; only the low order word is preserved
  1358 00000300 4989D8                  mov r8, rbx                                       ;Copy the tag word to the fifth standard parameter, namely: r8
  1359 00000303 B800000000              mov qword rax, 0                                  ;Set rax to 0 as standard signal to printf that only integer parameters are in use.
  1360 00000308 E8(00000000)            call printf
  1361                                  ;
  1362                                  ;
  1363                                  ;===== Begin section that outputs the contents of the Control Word ========================================================================
  1364                                  ;
  1365 0000030D 48BF-                   mov rdi, stringformat                             ;Set up for outputting headings over individual columns of the control word
  1366 0000030F [2A02000000000000] 
  1367 00000317 48BE-                   mov rsi, controlwordheading                       ;Provide the text for each heading over each column
  1368 00000319 [6C03000000000000] 
  1369 00000321 B800000000              mov qword rax, 0                                  ;rax must be zero unless the output includes fp numbers
  1370 00000326 E8(00000000)            call printf
  1371                                  
  1372 0000032B 41BF00000000            mov qword r15, 0
  1373 00000331 66448B3C24              mov word r15w, [rsp]                              ;r15 is the backup copy of the control word; r15w is the lowest 16 bits of r15
  1374                                  
  1375 00000336 48BF-                   mov rdi, stringformat                             ;Set up for string output only; no numeric outputs
  1376 00000338 [2A02000000000000] 
  1377 00000340 48BE-                   mov rsi, controlwordbit15_13                      ;Assign the start of the text to rsi
  1378 00000342 [B403000000000000] 
  1379 0000034A B800000000              mov qword rax, 0
  1380 0000034F E8(00000000)            call printf
  1381                                  
  1382 00000354 4C89FB                  mov rbx, r15                                      ;rbx is the working copy of the control word
  1383 00000357 4881E300100000          and rbx, xcontrol                                 ;Zero out all bits of the control word except bit #12
  1384 0000035E 48C1EB0C                shr rbx, 12                                       ;Shift bit number 12 to position #0
  1385 00000362 48BF-                   mov rdi, controlwordbit12
  1386 00000364 [D003000000000000] 
  1387 0000036C 4889DE                  mov rsi, rbx
  1388 0000036F B800000000              mov qword rax, 0                                  ;No fp numbers will be passed to parameters
  1389 00000374 E8(00000000)            call printf
  1390                                  
  1391 00000379 4C89FB                  mov rbx, r15                                      ;rbx is the working copy of the control word
  1392 0000037C 4881E3000C0000          and rbx, rcontrol                                 ;Zero out all bits of the control word except bits #10 and 11
  1393 00000383 48C1EB0A                shr rbx, 10                                       ;Shift bit number 10 to position #0
  1394 00000387 48BF-                   mov rdi, controlwordbit11_10
  1395 00000389 [F903000000000000] 
  1396 00000391 4889DE                  mov rsi, rbx
  1397 00000394 B800000000              mov qword rax, 0                                  ;No fp numbers will be passed to parameters
  1398 00000399 E8(00000000)            call printf
  1399                                  ;
  1400 0000039E 4C89FB                  mov rbx, r15                                      ;rbx is the working copy of the control word; r15 is the permanent copy of the control word
  1401 000003A1 4881E300030000          and rbx, pcontrol
  1402 000003A8 48C1EB08                shr rbx, 8                                        ;Shift bit number 8 to position #0
  1403 000003AC 48BF-                   mov rdi, controlwordbit9_8
  1404 000003AE [2204000000000000] 
  1405 000003B6 4889DE                  mov rsi, rbx
  1406 000003B9 B800000000              mov qword rax, 0                                  ;No fp numbers will be passed to parameters
  1407 000003BE E8(00000000)            call printf
  1408                                  ;
  1409 000003C3 48BF-                   mov rdi, stringformat                             ;Output a string message only; no numeric values will be displayed
  1410 000003C5 [2A02000000000000] 
  1411 000003CD 48BE-                   mov rsi, controlwordbit7_6                        ;Bits 7 and 6 are not used
  1412 000003CF [4C04000000000000] 
  1413 000003D7 B800000000              mov qword rax, 0                                  ;No fp numbers will be passed to parameters
  1414 000003DC E8(00000000)            call printf
  1415                                  ;
  1416 000003E1 4C89FB                  mov rbx, r15                                      ;rbx is the working copy of the control word; r15 is the permanent copy of the control word
  1417 000003E4 4883E320                and rbx, pmask
  1418 000003E8 48C1EB05                shr rbx, 5                                        ;Shift bit number 5 to position #0
  1419 000003EC 48BF-                   mov rdi, controlwordbit5
  1420 000003EE [6804000000000000] 
  1421 000003F6 4889DE                  mov rsi, rbx
  1422 000003F9 B800000000              mov qword rax, 0
  1423 000003FE E8(00000000)            call printf
  1424                                  ;
  1425 00000403 4C89FB                  mov rbx, r15                                      ;rbx is the working copy of the control word
  1426 00000406 4883E310                and rbx, umask
  1427 0000040A 48C1EB04                shr rbx, 4                                        ;Shift bit number 4 to position #0
  1428 0000040E 48BF-                   mov rdi, controlwordbit4
  1429 00000410 [8F04000000000000] 
  1430 00000418 4889DE                  mov rsi, rbx
  1431 0000041B B800000000              mov qword rax, 0
  1432 00000420 E8(00000000)            call printf
  1433                                  ;
  1434 00000425 4C89FB                  mov rbx, r15                                      ;rbx is the working copy of the control word; r15 is the permanent copy of the control word
  1435 00000428 4883E308                and rbx, omask                                    ;Zero out all bits except bit #3
  1436 0000042C 48C1EB03                shr rbx, 3                                        ;Shift bit number 3 to position #0
  1437 00000430 48BF-                   mov rdi, controlwordbit3
  1438 00000432 [B604000000000000] 
  1439 0000043A 4889DE                  mov rsi, rbx
  1440 0000043D B800000000              mov qword rax, 0
  1441 00000442 E8(00000000)            call printf
  1442                                  ;
  1443 00000447 4C89FB                  mov rbx, r15                                      ;rbx is the working copy of the control word; r15 is the permanent copy of the control word
  1444 0000044A 4883E304                and rbx, zmask
  1445 0000044E 48C1EB02                shr rbx, 2
  1446 00000452 48BF-                   mov rdi, controlwordbit2
  1447 00000454 [DC04000000000000] 
  1448 0000045C 4889DE                  mov rsi, rbx
  1449 0000045F B800000000              mov qword rax, 0
  1450 00000464 E8(00000000)            call printf
  1451                                  ;
  1452 00000469 4C89FB                  mov rbx, r15                                      ;rbx is the working copy of the control word; r15 is the permanent copy of the control word
  1453 0000046C 4883E302                and rbx, dmask
  1454 00000470 48D1EB                  shr rbx, 1
  1455 00000473 48BF-                   mov rdi, controlwordbit1
  1456 00000475 [0505000000000000] 
  1457 0000047D 4889DE                  mov rsi, rbx
  1458 00000480 B800000000              mov qword rax, 0
  1459 00000485 E8(00000000)            call printf
  1460                                  ;
  1461 0000048A 4C89FB                  mov rbx, r15                                      ;rbx is the working copy of the control word; r15 is the permanent copy of the control word
  1462 0000048D 4883E301                and rbx, imask
  1463                                  ;No shifting of bits is necessary
  1464 00000491 48BF-                   mov rdi, controlwordbit0
  1465 00000493 [3705000000000000] 
  1466 0000049B 4889DE                  mov rsi, rbx
  1467 0000049E B800000000              mov qword rax, 0
  1468 000004A3 E8(00000000)            call printf
  1469                                  ;
  1470                                  ;===== Begin section that outputs the bits of the Status Word =============================================================================
  1471                                  ;
  1472 000004A8 48BF-                   mov rdi, stringformat                             ;Set up for outputting headings over individual columns of the status word
  1473 000004AA [2A02000000000000] 
  1474 000004B2 48BE-                   mov rsi, statuswordheading                        ;Provide the text for each heading over each column
  1475 000004B4 [6605000000000000] 
  1476 000004BC B800000000              mov qword rax, 0                                  ;rax must be zero unless the output includes fp numbers
  1477 000004C1 E8(00000000)            call printf
  1478                                  ;
  1479 000004C6 41BF00000000            mov qword r15, 0
  1480 000004CC 66448B7C2404            mov word r15w, [rsp+4]                            ;r15 is the backup copy of the status word; r15w is the lowest 16 bits of r15
  1481 000004D2 4C89FB                  mov rbx, r15                                      ;rbx is the working copy of the status word
  1482 000004D5 4881E300800000          and rbx, bmask                                    ;Zero out all bits of status word except bit #15
  1483 000004DC 48C1EB0F                shr rbx, 15                                       ;Shift bit number 15 to position #0
  1484 000004E0 48BF-                   mov rdi, statuswordbit15
  1485 000004E2 [B607000000000000] 
  1486 000004EA 4889DE                  mov rsi, rbx
  1487 000004ED B800000000              mov qword rax, 0
  1488 000004F2 E8(00000000)            call printf
  1489                                  ;
  1490 000004F7 4C89FB                  mov rbx, r15                                      ;Get a new copy of the status word
  1491 000004FA 4881E300400000          and rbx, c3mask                                   ;Zero out all bits of status word except bit #14
  1492 00000501 48C1EB0E                shr rbx, 14                                       ;Shift bit number 14 to position #0
  1493 00000505 48BF-                   mov rdi, statuswordbit14
  1494 00000507 [8D07000000000000] 
  1495 0000050F 4889DE                  mov rsi, rbx
  1496 00000512 B800000000              mov qword rax, 0
  1497 00000517 E8(00000000)            call printf
  1498                                  ;
  1499 0000051C 4C89FB                  mov rbx, r15                                      ;Get a new copy of the status word
  1500 0000051F 4881E300380000          and rbx, tpmask                                   ;Zero out all bits of status word except bits #13, 12, and 11
  1501 00000526 48C1EB0B                shr rbx, 11                                       ;Shift bits 13, 12 and 11 to positions 2, 1, and 0
  1502 0000052A 48BF-                   mov rdi, statuswordbit11_13
  1503 0000052C [6807000000000000] 
  1504 00000534 4889DE                  mov rsi, rbx
  1505 00000537 B800000000              mov qword rax, 0
  1506 0000053C E8(00000000)            call printf
  1507                                  ;
  1508 00000541 4C89FB                  mov rbx, r15                                      ;Get a new copy of the status word
  1509 00000544 4881E300040000          and rbx, c2mask                                   ;Zero out all bits of status word except bit #10
  1510 0000054B 48C1EB0A                shr rbx, 10                                       ;Shift bit number 10 to position #0
  1511 0000054F 48BF-                   mov rdi, statuswordbit10
  1512 00000551 [3F07000000000000] 
  1513 00000559 4889DE                  mov rsi, rbx
  1514 0000055C B800000000              mov qword rax, 0
  1515 00000561 E8(00000000)            call printf
  1516                                  ;
  1517 00000566 4C89FB                  mov rbx, r15                                      ;Get a new copy of the status word
  1518 00000569 4881E300020000          and rbx, c1mask                                   ;Zero out all bits of status word except bit #9
  1519 00000570 48C1EB09                shr rbx, 9                                        ;Shift bit number 9 to position #0
  1520 00000574 48BF-                   mov rdi, statuswordbit9
  1521 00000576 [1607000000000000] 
  1522 0000057E 4889DE                  mov rsi, rbx
  1523 00000581 B800000000              mov qword rax, 0
  1524 00000586 E8(00000000)            call printf
  1525                                  ;
  1526 0000058B 4C89FB                  mov rbx, r15                                      ;Get a new copy of the status word
  1527 0000058E 4881E300010000          and rbx, c0mask                                   ;Zero out all bits of status word except bit #8
  1528 00000595 48C1EB08                shr rbx, 8                                        ;Shift bit number 8 to position #0
  1529 00000599 48BF-                   mov rdi, statuswordbit8
  1530 0000059B [ED06000000000000] 
  1531 000005A3 4889DE                  mov rsi, rbx
  1532 000005A6 B800000000              mov qword rax, 0
  1533 000005AB E8(00000000)            call printf
  1534                                  ;
  1535 000005B0 4C89FB                  mov rbx, r15                                      ;Get a new copy of the status word
  1536 000005B3 4881E380000000          and rbx, esmask                                   ;Zero out all bits of status word except bit #7
  1537 000005BA 48C1EB07                shr rbx, 7                                        ;Shift bit number 7 to position #0
  1538 000005BE 48BF-                   mov rdi, statuswordbit7
  1539 000005C0 [C006000000000000] 
  1540 000005C8 4889DE                  mov rsi, rbx
  1541 000005CB B800000000              mov qword rax, 0
  1542 000005D0 E8(00000000)            call printf
  1543                                  ;
  1544 000005D5 4C89FB                  mov rbx, r15                                      ;Get a new copy of the status word
  1545 000005D8 4883E340                and rbx, sfmask                                   ;Zero out all bits of status word except bit #6
  1546 000005DC 48C1EB06                shr rbx, 6                                        ;Shift bit number 6 to position #0
  1547 000005E0 48BF-                   mov rdi, statuswordbit6
  1548 000005E2 [9C06000000000000] 
  1549 000005EA 4889DE                  mov rsi, rbx
  1550 000005ED B800000000              mov qword rax, 0
  1551 000005F2 E8(00000000)            call printf
  1552                                  ;
  1553 000005F7 4C89FB                  mov rbx, r15                                      ;Get a new copy of the status word
  1554 000005FA 4883E320                and rbx, pemask                                   ;Zero out all bits of status word except bit #5
  1555 000005FE 48C1EB05                shr rbx, 5                                        ;Shift bit number 5 to position #0
  1556 00000602 48BF-                   mov rdi, statuswordbit5
  1557 00000604 [7A06000000000000] 
  1558 0000060C 4889DE                  mov rsi, rbx
  1559 0000060F B800000000              mov qword rax, 0
  1560 00000614 E8(00000000)            call printf
  1561                                  ;
  1562 00000619 4C89FB                  mov rbx, r15                                      ;Get a new copy of the status word
  1563 0000061C 4883E310                and rbx, uemask                                   ;Zero out all bits of status word except bit #4
  1564 00000620 48C1EB04                shr rbx, 4                                        ;Shift bit number 4 to position #0
  1565 00000624 48BF-                   mov rdi, statuswordbit4
  1566 00000626 [5806000000000000] 
  1567 0000062E 4889DE                  mov rsi, rbx
  1568 00000631 B800000000              mov qword rax, 0
  1569 00000636 E8(00000000)            call printf
  1570                                  ;
  1571 0000063B 4C89FB                  mov rbx, r15                                      ;Get a new copy of the status word
  1572 0000063E 4883E308                and rbx, oemask                                   ;Zero out all bits of status word except bit #3
  1573 00000642 48C1EB03                shr rbx, 3                                        ;Shift bit number 3 to position #0
  1574 00000646 48BF-                   mov rdi, statuswordbit3
  1575 00000648 [3706000000000000] 
  1576 00000650 4889DE                  mov rsi, rbx
  1577 00000653 B800000000              mov qword rax, 0
  1578 00000658 E8(00000000)            call printf
  1579                                  ;
  1580 0000065D 4C89FB                  mov rbx, r15                                      ;Get a new copy of the status word
  1581 00000660 4883E304                and rbx, zemask                                   ;Zero out all bits of the status word except bit #2
  1582 00000664 48C1EB02                shr rbx, 2                                        ;Shift bit number 2 to position #0
  1583 00000668 48BF-                   mov rdi, statuswordbit2
  1584 0000066A [1306000000000000] 
  1585 00000672 4889DE                  mov rsi, rbx
  1586 00000675 B800000000              mov qword rax, 0
  1587 0000067A E8(00000000)            call printf
  1588                                  ;
  1589 0000067F 4C89FB                  mov rbx, r15                                      ;Get a new copy of the status word
  1590 00000682 4883E302                and rbx, demask                                   ;Zero out all bits of the status word except bit #1
  1591 00000686 48D1EB                  shr rbx, 1                                        ;Shift bit number 1 to position #0
  1592 00000689 48BF-                   mov rdi, statuswordbit1
  1593 0000068B [E405000000000000] 
  1594 00000693 4889DE                  mov rsi, rbx
  1595 00000696 B800000000              mov qword rax, 0
  1596 0000069B E8(00000000)            call printf
  1597                                  ;
  1598 000006A0 4C89FB                  mov rbx, r15                                      ;Get a new copy of the status word
  1599 000006A3 4883E301                and rbx, iemask                                   ;Zero out all bits of the status word except bit #0
  1600                                  ;No shifting of bits is necessary
  1601 000006A7 48BF-                   mov rdi, statuswordbit0
  1602 000006A9 [BA05000000000000] 
  1603 000006B1 4889DE                  mov rsi, rbx
  1604 000006B4 B800000000              mov qword rax, 0
  1605 000006B9 E8(00000000)            call printf
  1606                                  ;
  1607                                  ;===== Begin section that outputs the contents of the Tag Word ============================================================================
  1608                                  ;
  1609 000006BE 48BF-                   mov rdi, stringformat                             ;Set up for outputting headings over individual columns of the status word
  1610 000006C0 [2A02000000000000] 
  1611 000006C8 48BE-                   mov rsi, tagwordheading                           ;Provide the text for each heading over each column
  1612 000006CA [D707000000000000] 
  1613 000006D2 B800000000              mov qword rax, 0                                  ;rax must be zero unless the output includes fp numbers
  1614 000006D7 E8(00000000)            call printf
  1615                                  ;
  1616 000006DC 41BF00000000            mov qword r15, 0
  1617 000006E2 66448B7C2408            mov word r15w, [rsp+8]                            ;r15 is the backup copy of the tag word; r15w is the lowest 16 bits of r15
  1618 000006E8 4C89FB                  mov rbx, r15                                      ;rbx is the working copy of the tag word
  1619 000006EB 4881E300C00000          and rbx, tag7mask                                 ;Zero out all bits except bits #15 and 14
  1620 000006F2 48C1EB0E                shr rbx, 14                                       ;Shift bit number 14 to position #0
  1621 000006F6 48BF-                   mov rdi, tag7bits15_14
  1622 000006F8 [A808000000000000] 
  1623 00000700 4889DE                  mov rsi, rbx
  1624 00000703 B800000000              mov qword rax, 0
  1625 00000708 E8(00000000)            call printf
  1626                                  ;
  1627 0000070D 4C89FB                  mov rbx, r15                                      ;rbx is the working copy of the tag word
  1628 00000710 4881E300300000          and rbx, tag6mask                                 ;Zero out all bits except bits #13 and 12
  1629 00000717 48C1EB0C                shr rbx, 12                                       ;Shift bit number 12 to position #0
  1630 0000071B 48BF-                   mov rdi, tag6bits13_12                            ;Place address of format into first standard parameter
  1631 0000071D [BE08000000000000] 
  1632 00000725 4889DE                  mov rsi, rbx                                      ;Place tag6 into the second standard parameter
  1633 00000728 B800000000              mov qword rax, 0                                  ;Indicate that no fp numbers will be passed to the function printf
  1634 0000072D E8(00000000)            call printf                                       ;Make print do the work
  1635                                  ;
  1636 00000732 4C89FB                  mov rbx, r15
  1637 00000735 4881E3000C0000          and rbx, tag5mask
  1638 0000073C 48C1EB0A                shr rbx, 10
  1639 00000740 48BF-                   mov rdi, tag5bits11_10
  1640 00000742 [D408000000000000] 
  1641 0000074A 4889DE                  mov rsi, rbx
  1642 0000074D B800000000              mov qword rax, 0
  1643 00000752 E8(00000000)            call printf
  1644                                  ;
  1645 00000757 4C89FB                  mov rbx, r15
  1646 0000075A 4881E300030000          and rbx, tag4mask
  1647 00000761 48C1EB08                shr rbx, 8
  1648 00000765 48BF-                   mov rdi, tag4bits9_8
  1649 00000767 [EA08000000000000] 
  1650 0000076F 4889DE                  mov rsi, rbx
  1651 00000772 B800000000              mov qword rax, 0
  1652 00000777 E8(00000000)            call printf
  1653                                  ;
  1654 0000077C 4C89FB                  mov rbx, r15
  1655 0000077F 4881E3C0000000          and rbx, tag3mask
  1656 00000786 48C1EB06                shr rbx, 6
  1657 0000078A 48BF-                   mov rdi, tag3bits7_6
  1658 0000078C [0009000000000000] 
  1659 00000794 4889DE                  mov rsi, rbx
  1660 00000797 B800000000              mov qword rax, 0
  1661 0000079C E8(00000000)            call printf
  1662                                  ;
  1663 000007A1 4C89FB                  mov rbx, r15
  1664 000007A4 4883E330                and rbx, tag2mask
  1665 000007A8 48C1EB04                shr rbx, 4
  1666 000007AC 48BF-                   mov rdi, tag2bits5_4
  1667 000007AE [1609000000000000] 
  1668 000007B6 4889DE                  mov rsi, rbx
  1669 000007B9 B800000000              mov qword rax, 0
  1670 000007BE E8(00000000)            call printf
  1671                                  ;
  1672 000007C3 4C89FB                  mov rbx, r15
  1673 000007C6 4883E30C                and rbx, tag1mask
  1674 000007CA 48C1EB02                shr rbx, 2
  1675 000007CE 48BF-                   mov rdi, tag1bits3_2
  1676 000007D0 [2C09000000000000] 
  1677 000007D8 4889DE                  mov rsi, rbx
  1678 000007DB B800000000              mov qword rax, 0
  1679 000007E0 E8(00000000)            call printf
  1680                                  ;
  1681 000007E5 4C89FB                  mov rbx, r15
  1682 000007E8 4883E303                and rbx, tag0mask
  1683                                  ;No shifting of bits is necessary
  1684 000007EC 48BF-                   mov rdi, tag0bits1_0
  1685 000007EE [4209000000000000] 
  1686 000007F6 4889DE                  mov rsi, rbx
  1687 000007F9 B800000000              mov qword rax, 0
  1688 000007FE E8(00000000)            call printf
  1689                                  ;
  1690                                  ;===== Begin setup of tag word for use in displaying type of contents of each fpu register ===============================================
  1691                                  ;
  1692                                  ;Initial configuration of tag word
  1693                                  ;   -----------------------------------------
  1694                                  ;   |tag7|tag6|tag5|tag4|tag3|tag2|tag1|tag0|
  1695                                  ;   -----------------------------------------
  1696                                  ;and each tag component is 2 bits.
  1697                                  ;The contents of TOP (within the Status word) indicates which tag associates with st0.  For instance, suppose TOP contain 5, then tag5 
  1698                                  ;identifies with register st0 as in the following diagram:
  1699                                  ;   -----------------------------------------
  1700                                  ;   |tag7|tag6|tag5|tag4|tag3|tag2|tag1|tag0|
  1701                                  ;   -----------------------------------------
  1702                                  ;     st2  st1  st0  st7  st6  st5  st4  st3
  1703                                  ;
  1704                                  ;The next step will be to rotate the Tag word to the right in order to align the tags with registers in the order st7 st6 st5 st4 st3 st2 
  1705                                  ;st1 st0.  Then the diagram will be as follows:
  1706                                  ;   -----------------------------------------
  1707                                  ;   |tag7|tag6|tag5|tag4|tag3|tag2|tag1|tag0|
  1708                                  ;   -----------------------------------------
  1709                                  ;     st7  st6  st5  st4  st3  st2  st1  st0
  1710                                  ;Then tag number k is associated with fpu register k.
  1711                                  ;
  1712                                  ;First obtain a copy of the top pointer.
  1713 00000803 41BF00000000            mov qword r15, 0                                  ;Make sure r15 contains only zeros before placing the status word in r15.
  1714 00000809 66448B7C2404            mov word r15w, [rsp+4]                            ;Now the status word is in the lowest word of the 4-word register r15
  1715 0000080F 4981E700380000          and r15, tpmask                                   ;Zero out all bits of status word except bits #13, 12, and 11
  1716 00000816 49C1EF0B                shr r15, 11                                       ;Shift bits 13, 12 and 11 to positions 2, 1, and 0.  
  1717                                  ;                                                 ;Now r15 contains only the top pointer.
  1718                                  ;
  1719                                  ;Obtain a copy of the Tag word.
  1720 0000081A 41BE00000000            mov qword r14, 0
  1721 00000820 66448B742408            mov word r14w, [rsp+8]                            ;The tag word is now in the lowest 2 bytes of r14.
  1722 00000826 4981E6FFFF0000          and r14, 000000000000ffffh                        ;Make sure the upper 6 bytes are all zeros.
  1723                                  ;
  1724                                  ;Now rotate the Tag word by 2*Top many bits.  The syntax requires that we use a loop rotating by 2 bits with each iteration of the loop.
  1725                                  beginrotateloop:                                  ;Assembly version of a while loop; test stop condition before loop iterates.
  1726 0000082D 4983FF00                     cmp qword r15, 0                             ;Compare: is r15 == 0?
  1727 00000831 740D                         je  exitrotateloop                           ;If r15 is 0 then the loop has finished.
  1728 00000833 6641D1CE                     ror r14w, 1                                  ;Rotate right 1 bit
  1729 00000837 6641D1CE                     ror r14w, 1                                  ;Rotate right 1 more bit.  Do it twice because tag cells hold two bits.
  1730 0000083B 49FFCF                       dec r15                                      ;r15 = r15 - 1
  1731 0000083E EBED                    jmp beginrotateloop
  1732                                  exitrotateloop:
  1733                                  ;
  1734                                  ;
  1735                                  ;
  1736                                  ;===== Begin section that outputs the contents of each FPU register =======================================================================
  1737                                  
  1738                                  ;Display headings over each column.  Column 1 = identifier of register; Column 2 = contents of register; Column 3 = tag value
  1739 00000840 48BF-                   mov qword rdi, stringformat                       ;First parameter receives the standard string format 
  1740 00000842 [2A02000000000000] 
  1741 0000084A 48BE-                   mov qword rsi, columnheadings                     ;Second parameter receives the string to be printed
  1742 0000084C [2D02000000000000] 
  1743 00000854 B800000000              mov qword rax, 0                                  ;No fp values will be outputted
  1744 00000859 E8(00000000)            call printf
  1745                                  
  1746                                  ;Begin section to output st7
  1747 0000085E 48BF-                   mov qword rdi, st7format                          ;Set the format for st7
  1748 00000860 [5102000000000000] 
  1749 00000868 488B74246A              mov qword rsi, [rsp+106]                          ;Copy the first 2 bytes of the number to the 2nd parameter
  1750 0000086D 4881E6FFFF0000          and rsi, 000000000000ffffh                        ;Make sure the 6 bytes of the high end are zeros
  1751 00000874 488B542462              mov qword rdx, [rsp+98]                           ;Copy the last 8 bytes of the number to the 3rd parameter
  1752                                  ;The tag cell for st7 is in bits 15 and 14 of the tag word r14.  We need that number to classify the data in st7.
  1753 00000879 4C89F3                  mov rbx, r14                                      ;Place a copy of the tag word into rbx
  1754 0000087C 4881E300C00000          and rbx, tag7mask                                 ;Make sure all bits other than bits 14 and 15 are zeros
  1755 00000883 48C1EB0E                shr rbx, 14                                       ;Shift the bit in position 14 to position 0
  1756                                  ;
  1757                                  ;A case statement will be used to evaluate the contents of rbx.
  1758                                  st7_case0:
  1759 00000887 4883FB00                    cmp rbx, 0                                    ;Check for case 0
  1760 0000088B 750C                        jne st7_case1                                 ;Jump to case 1 if this is not case 0.
  1761 0000088D 48B9-                       mov rcx, validnumber                          ;Copy the address of the classifying label to the 4th parameter.
  1762 0000088F [2D03000000000000] 
  1763 00000897 EB2E                        jmp st7_endcase                               ;Exit from the entire case statement
  1764                                  st7_case1:
  1765 00000899 4883FB01                    cmp rbx, 1                                    ;Check for case 1
  1766 0000089D 750C                        jne st7_case2                                 ;Jump to case 2 if this is not case 1.
  1767 0000089F 48B9-                       mov rcx, floatingpointzero                    ;Copy the address of the classifying label to the 4th parameter.
  1768 000008A1 [3A03000000000000] 
  1769 000008A9 EB1C                        jmp st7_endcase                               ;Exit from the entire case statement
  1770                                  st7_case2:
  1771 000008AB 4883FB02                    cmp rbx, 2                                    ;Check for case 2
  1772 000008AF 750C                        jne st7_case3                                 ;Jump to case 3 if this is not case 2.
  1773 000008B1 48B9-                       mov rcx, specialnumber                        ;Copy the address of the classifying label to the 4th parameter.
  1774 000008B3 [4603000000000000] 
  1775 000008BB EB0A                        jmp st7_endcase                               ;Exit from the entire case statement
  1776                                  st7_case3: ;default case -- if the numeric value in rbx is not (0 or 1 or 2) then it must be 3.
  1777 000008BD 48B9-                       mov rcx, emptyspace                           ;Copy the address of the classifying tag to the 4th parameter.
  1778 000008BF [1903000000000000] 
  1779                                  st7_endcase:                                      ;End of the case statement
  1780                                  ;
  1781 000008C7 B800000000              mov qword rax, 0                              
  1782 000008CC E8(00000000)            call printf
  1783                                  ;End of section to output st7
  1784                                  ;
  1785                                  ;
  1786                                  ;Begin section to output st6
  1787 000008D1 48BF-                   mov qword rdi, st6format                          ;Set the format for st6
  1788 000008D3 [6A02000000000000] 
  1789 000008DB 488B742460              mov qword rsi, [rsp+96]                           ;Copy the first 2 bytes of the number to the 2nd parameter
  1790 000008E0 4881E6FFFF0000          and rsi, 000000000000ffffh                        ;Make sure the 6 bytes of the high end are zeros
  1791 000008E7 488B542458              mov qword rdx, [rsp+88]                           ;Copy the last 8 bytes of the number to the 3rd parameter
  1792                                  ;The tag cell for st6 is in bits 13 and 12 of the tag word r14.  We need that number to classify the data in st6.
  1793 000008EC 4C89F3                  mov rbx, r14                                      ;Place a copy of the tag word into rbx
  1794 000008EF 4881E300300000          and rbx, tag6mask                                 ;Make sure all bits other than bits 13 and 12 are zeros
  1795 000008F6 48C1EB0C                shr rbx, 12                                       ;Shift the bit in position 12 to position 0
  1796                                  ;
  1797                                  ;A case statement will be used to evaluate the contents of rbx.
  1798                                  st6_case0:
  1799 000008FA 4883FB00                    cmp rbx, 0                                    ;Check for case 0
  1800 000008FE 750C                        jne st6_case1                                 ;Jump to case 1 if this is not case 0.
  1801 00000900 48B9-                       mov rcx, validnumber                          ;Copy the address of the classifying label to the 4th parameter.
  1802 00000902 [2D03000000000000] 
  1803 0000090A EB2E                        jmp st6_endcase                               ;Exit from the entire case statement
  1804                                  st6_case1:
  1805 0000090C 4883FB01                    cmp rbx, 1                                    ;Check for case 1
  1806 00000910 750C                        jne st6_case2                                 ;Jump to case 2 if this is not case 1.
  1807 00000912 48B9-                       mov rcx, floatingpointzero                    ;Copy the address of the classifying label to the 4th parameter.
  1808 00000914 [3A03000000000000] 
  1809 0000091C EB1C                        jmp st6_endcase                               ;Exit from the entire case statement
  1810                                  st6_case2:
  1811 0000091E 4883FB02                    cmp rbx, 2                                    ;Check for case 2
  1812 00000922 750C                        jne st6_case3                                 ;Jump to case 3 if this is not case 2.
  1813 00000924 48B9-                       mov rcx, specialnumber                        ;Copy the address of the classifying label to the 4th parameter.
  1814 00000926 [4603000000000000] 
  1815 0000092E EB0A                        jmp st6_endcase                               ;Exit from the entire case statement
  1816                                  st6_case3: ;default case -- if the numeric value in rbx is not (0 or 1 or 2) then it must be 3.
  1817 00000930 48B9-                       mov rcx, emptyspace                           ;Copy the address of the classifying tag to the 4th parameter.
  1818 00000932 [1903000000000000] 
  1819                                  st6_endcase:                                      ;End of the case statement
  1820                                  ;
  1821 0000093A B800000000              mov qword rax, 0                              
  1822 0000093F E8(00000000)            call printf
  1823                                  ;End of section to output st6
  1824                                  ;
  1825                                  ;
  1826                                  ;Begin section to output st5
  1827 00000944 48BF-                   mov qword rdi, st5format                          ;Set the format for st5
  1828 00000946 [8302000000000000] 
  1829 0000094E 488B742456              mov qword rsi, [rsp+86]                           ;Copy the first 2 bytes of the number to the 2nd parameter
  1830 00000953 4881E6FFFF0000          and rsi, 000000000000ffffh                        ;Make sure the 6 bytes of the high end are zeros
  1831 0000095A 488B54244E              mov qword rdx, [rsp+78]                           ;Copy the last 8 bytes of the number to the 3rd parameter
  1832                                  ;The tag cell for st5 is in bits 11 and 10 of the tag word r14.  We need that number to classify the data in st5.
  1833 0000095F 4C89F3                  mov rbx, r14                                      ;Place a copy of the tag word into rbx
  1834 00000962 4881E3000C0000          and rbx, tag5mask                                 ;Make sure all bits other than bits 11 and 10 are zeros
  1835 00000969 48C1EB0A                shr rbx, 10                                       ;Shift the bit in position 10 to position 0
  1836                                  ;
  1837                                  ;A case statement will be used to evaluate the contents of rbx.
  1838                                  st5_case0:
  1839 0000096D 4883FB00                    cmp rbx, 0                                    ;Check for case 0
  1840 00000971 750C                        jne st5_case1                                 ;Jump to case 1 if this is not case 0.
  1841 00000973 48B9-                       mov rcx, validnumber                          ;Copy the address of the classifying label to the 4th parameter.
  1842 00000975 [2D03000000000000] 
  1843 0000097D EB2E                        jmp st5_endcase                               ;Exit from the entire case statement
  1844                                  st5_case1:
  1845 0000097F 4883FB01                    cmp rbx, 1                                    ;Check for case 1
  1846 00000983 750C                        jne st5_case2                                 ;Jump to case 2 if this is not case 1.
  1847 00000985 48B9-                       mov rcx, floatingpointzero                    ;Copy the address of the classifying label to the 4th parameter.
  1848 00000987 [3A03000000000000] 
  1849 0000098F EB1C                        jmp st5_endcase                               ;Exit from the entire case statement
  1850                                  st5_case2:
  1851 00000991 4883FB02                    cmp rbx, 2                                    ;Check for case 2
  1852 00000995 750C                        jne st5_case3                                 ;Jump to case 3 if this is not case 2.
  1853 00000997 48B9-                       mov rcx, specialnumber                        ;Copy the address of the classifying label to the 4th parameter.
  1854 00000999 [4603000000000000] 
  1855 000009A1 EB0A                        jmp st5_endcase                               ;Exit from the entire case statement
  1856                                  st5_case3: ;default case -- if the numeric value in rbx is not (0 or 1 or 2) then it must be 3.
  1857 000009A3 48B9-                       mov rcx, emptyspace                           ;Copy the address of the classifying tag to the 4th parameter.
  1858 000009A5 [1903000000000000] 
  1859                                  st5_endcase:                                      ;End of the case statement
  1860                                  ;
  1861 000009AD B800000000              mov qword rax, 0                              
  1862 000009B2 E8(00000000)            call printf
  1863                                  ;End of section to output st5
  1864                                  ;
  1865                                  ;
  1866                                  ;Begin section to output st4
  1867 000009B7 48BF-                   mov qword rdi, st4format                          ;Set the format for st4
  1868 000009B9 [9C02000000000000] 
  1869 000009C1 488B74244C              mov qword rsi, [rsp+76]                           ;Copy the first 2 bytes of the number to the 2nd parameter
  1870 000009C6 4881E6FFFF0000          and rsi, 000000000000ffffh                        ;Make sure the 6 bytes of the high end are zeros
  1871 000009CD 488B542444              mov qword rdx, [rsp+68]                           ;Copy the last 8 bytes of the number to the 3rd parameter
  1872                                  ;The tag cell for st4 is in bits 9 and 8 of the tag word r14.  We need that number to classify the data in st4.
  1873 000009D2 4C89F3                  mov rbx, r14                                      ;Place a copy of the tag word into rbx
  1874 000009D5 4881E300030000          and rbx, tag4mask                                 ;Make sure all bits other than bits 9 and 8 are zeros
  1875 000009DC 48C1EB08                shr rbx, 8                                       ;Shift the bit in position 8 to position 0
  1876                                  ;
  1877                                  ;A case statement will be used to evaluate the contents of rbx.
  1878                                  st4_case0:
  1879 000009E0 4883FB00                    cmp rbx, 0                                    ;Check for case 0
  1880 000009E4 750C                        jne st4_case1                                 ;Jump to case 1 if this is not case 0.
  1881 000009E6 48B9-                       mov rcx, validnumber                          ;Copy the address of the classifying label to the 4th parameter.
  1882 000009E8 [2D03000000000000] 
  1883 000009F0 EB2E                        jmp st4_endcase                               ;Exit from the entire case statement
  1884                                  st4_case1:
  1885 000009F2 4883FB01                    cmp rbx, 1                                    ;Check for case 1
  1886 000009F6 750C                        jne st4_case2                                 ;Jump to case 2 if this is not case 1.
  1887 000009F8 48B9-                       mov rcx, floatingpointzero                    ;Copy the address of the classifying label to the 4th parameter.
  1888 000009FA [3A03000000000000] 
  1889 00000A02 EB1C                        jmp st4_endcase                               ;Exit from the entire case statement
  1890                                  st4_case2:
  1891 00000A04 4883FB02                    cmp rbx, 2                                    ;Check for case 2
  1892 00000A08 750C                        jne st4_case3                                 ;Jump to case 3 if this is not case 2.
  1893 00000A0A 48B9-                       mov rcx, specialnumber                        ;Copy the address of the classifying label to the 4th parameter.
  1894 00000A0C [4603000000000000] 
  1895 00000A14 EB0A                        jmp st4_endcase                               ;Exit from the entire case statement
  1896                                  st4_case3: ;default case -- if the numeric value in rbx is not (0 or 1 or 2) then it must be 3.
  1897 00000A16 48B9-                       mov rcx, emptyspace                           ;Copy the address of the classifying tag to the 4th parameter.
  1898 00000A18 [1903000000000000] 
  1899                                  st4_endcase:                                      ;End of the case statement
  1900                                  ;
  1901 00000A20 B800000000              mov qword rax, 0                              
  1902 00000A25 E8(00000000)            call printf
  1903                                  ;End of section to output st4
  1904                                  ;
  1905                                  ;
  1906                                  ;Begin section to output st3
  1907 00000A2A 48BF-                   mov qword rdi, st3format                          ;Set the format for st3
  1908 00000A2C [B502000000000000] 
  1909 00000A34 488B742442              mov qword rsi, [rsp+66]                           ;Copy the first 2 bytes of the number to the 2nd parameter
  1910 00000A39 4881E6FFFF0000          and rsi, 000000000000ffffh                        ;Make sure the 6 bytes of the high end are zeros
  1911 00000A40 488B54243A              mov qword rdx, [rsp+58]                           ;Copy the last 8 bytes of the number to the 3rd parameter
  1912                                  ;The tag cell for st3 is in bits 7 and 6 of the tag word r14.  We need that number to classify the data in st3.
  1913 00000A45 4C89F3                  mov rbx, r14                                      ;Place a copy of the tag word into rbx
  1914 00000A48 4881E3C0000000          and rbx, tag3mask                                 ;Make sure all bits other than bits 9 and 8 are zeros
  1915 00000A4F 48C1EB06                shr rbx, 6                                       ;Shift the bit in position 6 to position 0
  1916                                  ;
  1917                                  ;A case statement will be used to evaluate the contents of rbx.
  1918                                  st3_case0:
  1919 00000A53 4883FB00                    cmp rbx, 0                                    ;Check for case 0
  1920 00000A57 750C                        jne st3_case1                                 ;Jump to case 1 if this is not case 0.
  1921 00000A59 48B9-                       mov rcx, validnumber                          ;Copy the address of the classifying label to the 4th parameter.
  1922 00000A5B [2D03000000000000] 
  1923 00000A63 EB2E                        jmp st3_endcase                               ;Exit from the entire case statement
  1924                                  st3_case1:
  1925 00000A65 4883FB01                    cmp rbx, 1                                    ;Check for case 1
  1926 00000A69 750C                        jne st3_case2                                 ;Jump to case 2 if this is not case 1.
  1927 00000A6B 48B9-                       mov rcx, floatingpointzero                    ;Copy the address of the classifying label to the 4th parameter.
  1928 00000A6D [3A03000000000000] 
  1929 00000A75 EB1C                        jmp st3_endcase                               ;Exit from the entire case statement
  1930                                  st3_case2:
  1931 00000A77 4883FB02                    cmp rbx, 2                                    ;Check for case 2
  1932 00000A7B 750C                        jne st3_case3                                 ;Jump to case 3 if this is not case 2.
  1933 00000A7D 48B9-                       mov rcx, specialnumber                        ;Copy the address of the classifying label to the 4th parameter.
  1934 00000A7F [4603000000000000] 
  1935 00000A87 EB0A                        jmp st3_endcase                               ;Exit from the entire case statement
  1936                                  st3_case3: ;default case -- if the numeric value in rbx is not (0 or 1 or 2) then it must be 3.
  1937 00000A89 48B9-                       mov rcx, emptyspace                           ;Copy the address of the classifying tag to the 4th parameter.
  1938 00000A8B [1903000000000000] 
  1939                                  st3_endcase:                                      ;End of the case statement
  1940                                  ;
  1941 00000A93 B800000000              mov qword rax, 0                              
  1942 00000A98 E8(00000000)            call printf
  1943                                  ;End of section to output st3
  1944                                  ;
  1945                                  ;
  1946                                  ;Begin section to output st2
  1947 00000A9D 48BF-                   mov qword rdi, st2format                          ;Set the format for st2
  1948 00000A9F [CE02000000000000] 
  1949 00000AA7 488B742438              mov qword rsi, [rsp+56]                           ;Copy the first 2 bytes of the number to the 2nd parameter
  1950 00000AAC 4881E6FFFF0000          and rsi, 000000000000ffffh                        ;Make sure the 6 bytes of the high end are zeros
  1951 00000AB3 488B542430              mov qword rdx, [rsp+48]                           ;Copy the last 8 bytes of the number to the 3rd parameter
  1952                                  ;The tag cell for st2 is in bits 5 and 4 of the tag word r14.  We need that number to classify the data in st2.
  1953 00000AB8 4C89F3                  mov rbx, r14                                      ;Place a copy of the tag word into rbx
  1954 00000ABB 4883E330                and rbx, tag2mask                                 ;Make sure all bits other than bits 5 and 4 are zeros
  1955 00000ABF 48C1EB04                shr rbx, 4                                        ;Shift the bit in position 4 to position 0
  1956                                  ;
  1957                                  ;A case statement will be used to evaluate the contents of rbx.
  1958                                  st2_case0:
  1959 00000AC3 4883FB00                    cmp rbx, 0                                    ;Check for case 0
  1960 00000AC7 750C                        jne st2_case1                                 ;Jump to case 1 if this is not case 0.
  1961 00000AC9 48B9-                       mov rcx, validnumber                          ;Copy the address of the classifying label to the 4th parameter.
  1962 00000ACB [2D03000000000000] 
  1963 00000AD3 EB2E                        jmp st2_endcase                               ;Exit from the entire case statement
  1964                                  st2_case1:
  1965 00000AD5 4883FB01                    cmp rbx, 1                                    ;Check for case 1
  1966 00000AD9 750C                        jne st2_case2                                 ;Jump to case 2 if this is not case 1.
  1967 00000ADB 48B9-                       mov rcx, floatingpointzero                    ;Copy the address of the classifying label to the 4th parameter.
  1968 00000ADD [3A03000000000000] 
  1969 00000AE5 EB1C                        jmp st2_endcase                               ;Exit from the entire case statement
  1970                                  st2_case2:
  1971 00000AE7 4883FB02                    cmp rbx, 2                                    ;Check for case 2
  1972 00000AEB 750C                        jne st2_case3                                 ;Jump to case 3 if this is not case 2.
  1973 00000AED 48B9-                       mov rcx, specialnumber                        ;Copy the address of the classifying label to the 4th parameter.
  1974 00000AEF [4603000000000000] 
  1975 00000AF7 EB0A                        jmp st2_endcase                               ;Exit from the entire case statement
  1976                                  st2_case3: ;default case -- if the numeric value in rbx is not (0 or 1 or 2) then it must be 3.
  1977 00000AF9 48B9-                       mov rcx, emptyspace                           ;Copy the address of the classifying tag to the 4th parameter.
  1978 00000AFB [1903000000000000] 
  1979                                  st2_endcase:                                      ;End of the case statement
  1980                                  ;
  1981 00000B03 B800000000              mov qword rax, 0                              
  1982 00000B08 E8(00000000)            call printf
  1983                                  ;End of section to output st2
  1984                                  ;
  1985                                  ;
  1986                                  ;Begin section to output st1
  1987 00000B0D 48BF-                   mov qword rdi, st1format                          ;Set the format for st1
  1988 00000B0F [E702000000000000] 
  1989 00000B17 488B74242E              mov qword rsi, [rsp+46]                           ;Copy the first 2 bytes of the number to the 2nd parameter
  1990 00000B1C 4881E6FFFF0000          and rsi, 000000000000ffffh                        ;Make sure the 6 bytes of the high end are zeros
  1991 00000B23 488B542426              mov qword rdx, [rsp+38]                           ;Copy the last 8 bytes of the number to the 3rd parameter
  1992                                  ;The tag cell for st1 is in bits 3 and 2 of the tag word r14.  We need that number to classify the data in st1.
  1993 00000B28 4C89F3                  mov rbx, r14                                      ;Place a copy of the tag word into rbx
  1994 00000B2B 4883E30C                and rbx, tag1mask                                 ;Make sure all bits other than bits 3 and 2 are zeros
  1995 00000B2F 48C1EB02                shr rbx, 2                                        ;Shift the bit in position 2 to position 0
  1996                                  ;
  1997                                  ;A case statement will be used to evaluate the contents of rbx.
  1998                                  st1_case0:
  1999 00000B33 4883FB00                    cmp rbx, 0                                    ;Check for case 0
  2000 00000B37 750C                        jne st1_case1                                 ;Jump to case 1 if this is not case 0.
  2001 00000B39 48B9-                       mov rcx, validnumber                          ;Copy the address of the classifying label to the 4th parameter.
  2002 00000B3B [2D03000000000000] 
  2003 00000B43 EB2E                        jmp st1_endcase                               ;Exit from the entire case statement
  2004                                  st1_case1:
  2005 00000B45 4883FB01                    cmp rbx, 1                                    ;Check for case 1
  2006 00000B49 750C                        jne st1_case2                                 ;Jump to case 2 if this is not case 1.
  2007 00000B4B 48B9-                       mov rcx, floatingpointzero                    ;Copy the address of the classifying label to the 4th parameter.
  2008 00000B4D [3A03000000000000] 
  2009 00000B55 EB1C                        jmp st1_endcase                               ;Exit from the entire case statement
  2010                                  st1_case2:
  2011 00000B57 4883FB02                    cmp rbx, 2                                    ;Check for case 2
  2012 00000B5B 750C                        jne st1_case3                                 ;Jump to case 3 if this is not case 2.
  2013 00000B5D 48B9-                       mov rcx, specialnumber                        ;Copy the address of the classifying label to the 4th parameter.
  2014 00000B5F [4603000000000000] 
  2015 00000B67 EB0A                        jmp st1_endcase                               ;Exit from the entire case statement
  2016                                  st1_case3: ;default case -- if the numeric value in rbx is not (0 or 1 or 2) then it must be 3.
  2017 00000B69 48B9-                       mov rcx, emptyspace                           ;Copy the address of the classifying tag to the 4th parameter.
  2018 00000B6B [1903000000000000] 
  2019                                  st1_endcase:                                      ;End of the case statement
  2020                                  ;
  2021 00000B73 B800000000              mov qword rax, 0                                  ;No fp values will be passed to parameters
  2022 00000B78 E8(00000000)            call printf
  2023                                  ;End of section to output st1
  2024                                  ;
  2025                                  ;
  2026                                  ;Begin section to output st0
  2027 00000B7D 48BF-                   mov qword rdi, st0format                          ;Set the format for st0
  2028 00000B7F [0003000000000000] 
  2029 00000B87 488B742424              mov qword rsi, [rsp+36]                           ;Copy the first 2 bytes of the number to the 2nd parameter
  2030 00000B8C 4881E6FFFF0000          and rsi, 000000000000ffffh                        ;Make sure the 6 bytes of the high end are zeros
  2031 00000B93 488B54241C              mov qword rdx, [rsp+28]                           ;Copy the last 8 bytes of the number to the 3rd parameter
  2032                                  
  2033                                  ;The tag cell for st0 is in bits 1 and 0 of the tag word r14.  We need that number to classify the data in st7.
  2034 00000B98 4C89F3                  mov rbx, r14                                      ;Place a copy of the tag word into rbx
  2035 00000B9B 4883E303                and rbx, tag0mask                                 ;Make sure all bits other than bits 1 and 0 are zeros
  2036                                  ;
  2037                                  ;A case statement will be used to evaluate the contents of rbx.
  2038                                  st0_case0:
  2039 00000B9F 4883FB00                    cmp rbx, 0                                    ;Check for case 0
  2040 00000BA3 750C                        jne st0_case1                                 ;Jump to case 1 if this is not case 0.
  2041 00000BA5 48B9-                       mov rcx, validnumber                          ;Copy the address of the classifying label to the 4th parameter.
  2042 00000BA7 [2D03000000000000] 
  2043 00000BAF EB2E                        jmp st0_endcase                               ;Exit from the entire case statement
  2044                                  st0_case1:
  2045 00000BB1 4883FB01                    cmp rbx, 1                                    ;Check for case 1
  2046 00000BB5 750C                        jne st0_case2                                 ;Jump to case 2 if this is not case 1.
  2047 00000BB7 48B9-                       mov rcx, floatingpointzero                    ;Copy the address of the classifying label to the 4th parameter.
  2048 00000BB9 [3A03000000000000] 
  2049 00000BC1 EB1C                        jmp st0_endcase                               ;Exit from the entire case statement
  2050                                  st0_case2:
  2051 00000BC3 4883FB02                    cmp rbx, 2                                    ;Check for case 2
  2052 00000BC7 750C                        jne st0_case3                                 ;Jump to case 2 if this is not case 1.
  2053 00000BC9 48B9-                       mov rcx, specialnumber                        ;Copy the address of the classifying label to the 4th parameter.
  2054 00000BCB [4603000000000000] 
  2055 00000BD3 EB0A                        jmp st0_endcase                               ;Exit from the entire case statement
  2056                                  st0_case3: ;default case -- if the numeric value in rbx is not (0 or 1 or 2) then it must be 3.
  2057 00000BD5 48B9-                       mov rcx, emptyspace                           ;Copy the address of the classifying tag to the 4th parameter.
  2058 00000BD7 [1903000000000000] 
  2059                                  st0_endcase:                                      ;End of the case statement
  2060                                  ;
  2061 00000BDF B800000000              mov qword rax, 0                                  ;No fp values will be passed to parameters.
  2062 00000BE4 E8(00000000)            call printf
  2063                                  ;End of section to output st0
  2064                                  
  2065                                  ;===============================
  2066                                  ;End of showing FPU registers  |
  2067                                  ;===============================
  2068                                  ;
  2069                                  ;Dr Carter's program restores all the data in the FPU from memory.  Therefore, we do it here also. 
  2070                                  ;Think of the frstor instruction as the reverse of the fsave instruction; it restores all the fpu registers from the system stack.  
  2071                                  ;Scan the source code above belonging to the function showfpusubprogram and notice that between the fsave instruction and the frstor 
  2072                                  ;instruction below the system stack is never modified.  Therefore, it should be safe to apply the frstor instruction.
  2073                                  ;
  2074 00000BE9 DD2424                  frstor [rsp]   ;Hopefully rsp has not changed since the fsave instruction was executed earlier.
  2075                                  ;
  2076                                  ;===== Time to clean up and return to the caller ==========================================================================================
  2077                                  ;This program is preparing to terminate.  It is time to reverse those earlier pushes.
  2078                                  
  2079                                  ;First do 14 pops and discard any data.  Undoubtedly Dr Carter has a more sophisticated way to accomplish the same result.
  2080 00000BEC 58                      pop rax  ;pop #1
  2081 00000BED 58                      pop rax  ;pop #2
  2082 00000BEE 58                      pop rax  ;pop #3
  2083 00000BEF 58                      pop rax  ;pop #4
  2084 00000BF0 58                      pop rax  ;pop #5
  2085 00000BF1 58                      pop rax  ;pop #6
  2086 00000BF2 58                      pop rax  ;pop #7
  2087 00000BF3 58                      pop rax  ;pop #8
  2088 00000BF4 58                      pop rax  ;pop #9
  2089 00000BF5 58                      pop rax  ;pop #10
  2090 00000BF6 58                      pop rax  ;pop #11
  2091 00000BF7 58                      pop rax  ;pop #12
  2092 00000BF8 58                      pop rax  ;pop #13
  2093 00000BF9 58                      pop rax  ;pop #14
  2094                                  ;
  2095                                  ;Restore orginal values to the integer registers
  2096 00000BFA 9D                      popf                                                        ;Restore rflags
  2097 00000BFB 5B                      pop rbx                                                     ;Restore rbx
  2098 00000BFC 415F                    pop r15                                                     ;Restore r15
  2099 00000BFE 415E                    pop r14                                                     ;Restore r14
  2100 00000C00 415D                    pop r13                                                     ;Restore r13
  2101 00000C02 415C                    pop r12                                                     ;Restore r12
  2102 00000C04 415B                    pop r11                                                     ;Restore r11
  2103 00000C06 415A                    pop r10                                                     ;Restore r10
  2104 00000C08 4159                    pop r9                                                      ;Restore r9
  2105 00000C0A 4158                    pop r8                                                      ;Restore r8
  2106 00000C0C 59                      pop rcx                                                     ;Restore rcx
  2107 00000C0D 5A                      pop rdx                                                     ;Restore rdx
  2108 00000C0E 5E                      pop rsi                                                     ;Restore rsi
  2109 00000C0F 5F                      pop rdi                                                     ;Restore rdi
  2110 00000C10 5D                      pop rbp                                                     ;Restore rbp
  2111                                  ;
  2112                                  ;
  2113                                  ;= = = = = = End of data output = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 
  2114                                  ;
  2115                                  ;Say good-bye                                               ;Finally, we arrive at the end of this little program.
  2116 00000C11 48BF-                   mov qword rdi, stringformat                                 ;A little good-bye message will be outputted.
  2117 00000C13 [2A02000000000000] 
  2118 00000C1B 48BE-                   mov qword rsi, farewell
  2119 00000C1D [5809000000000000] 
  2120 00000C25 B800000000              mov qword rax, 0
  2121 00000C2A E8(00000000)            call printf
  2122                                  ;
  2123                                  ;Prepare to return a zero
  2124 00000C2F B800000000              mov qword rax, 0                                            ;Return value 0 indicates successful conclusion.
  2125 00000C34 C20800                  ret 8                                                       ;Return to the address on top of the stack and then discard one qword from the top of the stack.
  2126                                  ;End of showfpusubprogram 
  2127                                  ;========== End of showfpusubprogram ======================================================================================================
  2128                                  ;
  2129                                  ;
  2130                                  ;==========================================================================================================================================
  2131                                  ;                             Show XMM Registers Subprogram
  2132                                  ;==========================================================================================================================================
  2133                                  
  2134                                  
  2135                                  global showxmmsubprogram
  2136                                  
  2137                                  segment .data
  2138                                  
  2139 00000971 257300                  formatstring db "%s", 0
  2140 00000974 535345322044756D70-     formatdumpnumber db "SSE2 Dump # %ld", 10, 0
  2141 0000097D 202320256C640A00   
  2142 00000985 786D6D232320202020-     formatsseheader db "xmm##        high64              low64", 10, 0
  2143 0000098E 202020206869676836-
  2144 00000997 342020202020202020-
  2145 000009A0 2020202020206C6F77-
  2146 000009A9 36340A00           
  2147 000009AD 786D6D31353A202025-     formatxmm15 db     "xmm15:  %016lx    %016lx", 10, 0
  2148 000009B6 3031366C7820202020-
  2149 000009BF 253031366C780A00   
  2150 000009C7 786D6D31343A202025-     formatxmm14 db     "xmm14:  %016lx    %016lx", 10, 0
  2151 000009D0 3031366C7820202020-
  2152 000009D9 253031366C780A00   
  2153 000009E1 786D6D31333A202025-     formatxmm13 db     "xmm13:  %016lx    %016lx", 10, 0
  2154 000009EA 3031366C7820202020-
  2155 000009F3 253031366C780A00   
  2156 000009FB 786D6D31323A202025-     formatxmm12 db     "xmm12:  %016lx    %016lx", 10, 0
  2157 00000A04 3031366C7820202020-
  2158 00000A0D 253031366C780A00   
  2159 00000A15 786D6D31313A202025-     formatxmm11 db     "xmm11:  %016lx    %016lx", 10, 0
  2160 00000A1E 3031366C7820202020-
  2161 00000A27 253031366C780A00   
  2162 00000A2F 786D6D31303A202025-     formatxmm10 db     "xmm10:  %016lx    %016lx", 10, 0
  2163 00000A38 3031366C7820202020-
  2164 00000A41 253031366C780A00   
  2165 00000A49 786D6D393A20202025-     formatxmm9  db     "xmm9:   %016lx    %016lx", 10, 0
  2166 00000A52 3031366C7820202020-
  2167 00000A5B 253031366C780A00   
  2168 00000A63 786D6D383A20202025-     formatxmm8  db     "xmm8:   %016lx    %016lx", 10, 0
  2169 00000A6C 3031366C7820202020-
  2170 00000A75 253031366C780A00   
  2171 00000A7D 786D6D373A20202025-     formatxmm7  db     "xmm7:   %016lx    %016lx", 10, 0
  2172 00000A86 3031366C7820202020-
  2173 00000A8F 253031366C780A00   
  2174 00000A97 786D6D363A20202025-     formatxmm6  db     "xmm6:   %016lx    %016lx", 10, 0
  2175 00000AA0 3031366C7820202020-
  2176 00000AA9 253031366C780A00   
  2177 00000AB1 786D6D353A20202025-     formatxmm5  db     "xmm5:   %016lx    %016lx", 10, 0
  2178 00000ABA 3031366C7820202020-
  2179 00000AC3 253031366C780A00   
  2180 00000ACB 786D6D343A20202025-     formatxmm4  db     "xmm4:   %016lx    %016lx", 10, 0
  2181 00000AD4 3031366C7820202020-
  2182 00000ADD 253031366C780A00   
  2183 00000AE5 786D6D333A20202025-     formatxmm3  db     "xmm3:   %016lx    %016lx", 10, 0
  2184 00000AEE 3031366C7820202020-
  2185 00000AF7 253031366C780A00   
  2186 00000AFF 786D6D323A20202025-     formatxmm2  db     "xmm2:   %016lx    %016lx", 10, 0
  2187 00000B08 3031366C7820202020-
  2188 00000B11 253031366C780A00   
  2189 00000B19 786D6D313A20202025-     formatxmm1  db     "xmm1:   %016lx    %016lx", 10, 0
  2190 00000B22 3031366C7820202020-
  2191 00000B2B 253031366C780A00   
  2192 00000B33 786D6D303A20202025-     formatxmm0  db     "xmm0:   %016lx    %016lx", 10, 0
  2193 00000B3C 3031366C7820202020-
  2194 00000B45 253031366C780A00   
  2195                                  
  2196                                  segment .text
  2197                                  showxmmsubprogram:
  2198                                  
  2199                                  ;========== Create backups for integer registers ========================================================================================
  2200                                  ;Safe programming practice: save all the data that may possibly be modified within this subprogram.  Intentionally the registers rsp
  2201                                  ;and rax are not backed up.
  2202 00000C37 55                      push rbp                                                    ;Back up the very important base pointer register
  2203 00000C38 57                      push rdi                                                    ;Back up rdi
  2204 00000C39 56                      push rsi                                                    ;Back up rsi
  2205 00000C3A 52                      push rdx                                                    ;Back up rdx
  2206 00000C3B 51                      push rcx                                                    ;Back up rcx
  2207 00000C3C 4150                    push r8                                                     ;Back up r8
  2208 00000C3E 4151                    push r9                                                     ;Back up r9
  2209 00000C40 4152                    push r10                                                    ;Back up r10
  2210 00000C42 4153                    push r11                                                    ;Back up r11
  2211 00000C44 4154                    push r12                                                    ;Back up r12
  2212 00000C46 4155                    push r13                                                    ;Back up r13
  2213 00000C48 4156                    push r14                                                    ;Back up r14
  2214 00000C4A 4157                    push r15                                                    ;Back up r15
  2215 00000C4C 53                      push rbx                                                    ;Back up rbx
  2216 00000C4D 9C                      pushf                                                       ;Back up rflags
  2217                                  
  2218                                  ;========== Copy all xmm values to the integer stack ====================================================================================
  2219 00000C4E 90<rept>                align 16
  2220 00000C50 6A00                    push qword 0
  2221 00000C52 6A00                    push qword 0
  2222 00000C54 66440F113C24            movupd     [rsp], xmm15
  2223 00000C5A 6A00                    push qword 0
  2224 00000C5C 6A00                    push qword 0
  2225 00000C5E 66440F113424            movupd     [rsp], xmm14
  2226 00000C64 6A00                    push qword 0
  2227 00000C66 6A00                    push qword 0
  2228 00000C68 66440F112C24            movupd     [rsp], xmm13
  2229 00000C6E 6A00                    push qword 0
  2230 00000C70 6A00                    push qword 0
  2231 00000C72 66440F112424            movupd     [rsp], xmm12
  2232 00000C78 6A00                    push qword 0
  2233 00000C7A 6A00                    push qword 0
  2234 00000C7C 66440F111C24            movupd     [rsp], xmm11
  2235 00000C82 6A00                    push qword 0
  2236 00000C84 6A00                    push qword 0
  2237 00000C86 66440F111424            movupd     [rsp], xmm10
  2238 00000C8C 6A00                    push qword 0
  2239 00000C8E 6A00                    push qword 0
  2240 00000C90 66440F110C24            movupd     [rsp], xmm9
  2241 00000C96 6A00                    push qword 0
  2242 00000C98 6A00                    push qword 0
  2243 00000C9A 66440F110424            movupd     [rsp], xmm8
  2244 00000CA0 6A00                    push qword 0
  2245 00000CA2 6A00                    push qword 0
  2246 00000CA4 660F113C24              movupd     [rsp], xmm7
  2247 00000CA9 6A00                    push qword 0
  2248 00000CAB 6A00                    push qword 0
  2249 00000CAD 660F113424              movupd     [rsp], xmm6
  2250 00000CB2 6A00                    push qword 0
  2251 00000CB4 6A00                    push qword 0
  2252 00000CB6 660F112C24              movupd     [rsp], xmm5
  2253 00000CBB 6A00                    push qword 0
  2254 00000CBD 6A00                    push qword 0
  2255 00000CBF 660F112424              movupd     [rsp], xmm4
  2256 00000CC4 6A00                    push qword 0
  2257 00000CC6 6A00                    push qword 0
  2258 00000CC8 660F111C24              movupd     [rsp], xmm3
  2259 00000CCD 6A00                    push qword 0
  2260 00000CCF 6A00                    push qword 0
  2261 00000CD1 660F111424              movupd     [rsp], xmm2
  2262 00000CD6 6A00                    push qword 0
  2263 00000CD8 6A00                    push qword 0
  2264 00000CDA 660F110C24              movupd     [rsp], xmm1
  2265 00000CDF 6A00                    push qword 0
  2266 00000CE1 6A00                    push qword 0
  2267 00000CE3 660F110424              movupd     [rsp], xmm0
  2268                                  ;========= End of copying xmm values to the integer stack =================================================================================
  2269                                  
  2270                                  ;========= Begin section that will display all the xmm values =============================================================================
  2271 00000CE8 90<rept>                align 16
  2272 00000CF0 B800000000              mov qword  rax, 0
  2273 00000CF5 48BF-                   mov        rdi, formatdumpnumber
  2274 00000CF7 [7409000000000000] 
  2275 00000CFF 488BB42480010000        mov        rsi, [rsp+48*8]
  2276 00000D07 E8(00000000)            call       printf
  2277 00000D0C B800000000              mov qword  rax, 0
  2278 00000D11 48BF-                   mov        rdi, formatstring                                ;"%s", 0
  2279 00000D13 [7109000000000000] 
  2280 00000D1B 48BE-                   mov        rsi, formatsseheader                             ;"xmm**    high64    low64"
  2281 00000D1D [8509000000000000] 
  2282 00000D25 E8(00000000)            call       printf
  2283 00000D2A B800000000              mov qword  rax, 0
  2284 00000D2F 48BF-                   mov        rdi, formatxmm15
  2285 00000D31 [AD09000000000000] 
  2286 00000D39 488BB424F8000000        mov        rsi, [rsp+31*8]
  2287 00000D41 488B9424F0000000        mov        rdx, [rsp+30*8]
  2288 00000D49 E8(00000000)            call       printf
  2289 00000D4E B800000000              mov qword  rax, 0
  2290 00000D53 48BF-                   mov        rdi, formatxmm14
  2291 00000D55 [C709000000000000] 
  2292 00000D5D 488BB424E8000000        mov        rsi, [rsp+29*8]
  2293 00000D65 488B9424E0000000        mov        rdx, [rsp+28*8]
  2294 00000D6D E8(00000000)            call       printf
  2295 00000D72 B800000000              mov qword  rax, 0
  2296 00000D77 48BF-                   mov        rdi, formatxmm13
  2297 00000D79 [E109000000000000] 
  2298 00000D81 488BB424D8000000        mov        rsi, [rsp+27*8]
  2299 00000D89 488B9424D0000000        mov        rdx, [rsp+26*8]
  2300 00000D91 E8(00000000)            call       printf
  2301 00000D96 B800000000              mov qword  rax, 0
  2302 00000D9B 48BF-                   mov        rdi, formatxmm12
  2303 00000D9D [FB09000000000000] 
  2304 00000DA5 488BB424C8000000        mov        rsi, [rsp+25*8]
  2305 00000DAD 488B9424C0000000        mov        rdx, [rsp+24*8]
  2306 00000DB5 E8(00000000)            call       printf
  2307 00000DBA B800000000              mov qword  rax, 0
  2308 00000DBF 48BF-                   mov        rdi, formatxmm11
  2309 00000DC1 [150A000000000000] 
  2310 00000DC9 488BB424B8000000        mov        rsi, [rsp+23*8]
  2311 00000DD1 488B9424B0000000        mov        rdx, [rsp+22*8]
  2312 00000DD9 E8(00000000)            call       printf
  2313 00000DDE B800000000              mov qword  rax, 0
  2314 00000DE3 48BF-                   mov        rdi, formatxmm10
  2315 00000DE5 [2F0A000000000000] 
  2316 00000DED 488BB424A8000000        mov        rsi, [rsp+21*8]
  2317 00000DF5 488B9424A0000000        mov        rdx, [rsp+20*8]
  2318 00000DFD E8(00000000)            call       printf
  2319 00000E02 B800000000              mov qword  rax, 0
  2320 00000E07 48BF-                   mov        rdi, formatxmm9
  2321 00000E09 [490A000000000000] 
  2322 00000E11 488BB42498000000        mov        rsi, [rsp+19*8]
  2323 00000E19 488B942490000000        mov        rdx, [rsp+18*8]
  2324 00000E21 E8(00000000)            call       printf
  2325 00000E26 B800000000              mov qword  rax, 0
  2326 00000E2B 48BF-                   mov        rdi, formatxmm8
  2327 00000E2D [630A000000000000] 
  2328 00000E35 488BB42488000000        mov        rsi, [rsp+17*8]
  2329 00000E3D 488B942480000000        mov        rdx, [rsp+16*8]
  2330 00000E45 E8(00000000)            call       printf
  2331 00000E4A B800000000              mov qword  rax, 0
  2332 00000E4F 48BF-                   mov        rdi, formatxmm7
  2333 00000E51 [7D0A000000000000] 
  2334 00000E59 488B742478              mov        rsi, [rsp+15*8]
  2335 00000E5E 488B542470              mov        rdx, [rsp+14*8]
  2336 00000E63 E8(00000000)            call       printf
  2337 00000E68 B800000000              mov qword  rax, 0
  2338 00000E6D 48BF-                   mov        rdi, formatxmm6
  2339 00000E6F [970A000000000000] 
  2340 00000E77 488B742468              mov        rsi, [rsp+13*8]
  2341 00000E7C 488B542460              mov        rdx, [rsp+12*8]
  2342 00000E81 E8(00000000)            call       printf
  2343 00000E86 B800000000              mov qword  rax, 0
  2344 00000E8B 48BF-                   mov        rdi, formatxmm5
  2345 00000E8D [B10A000000000000] 
  2346 00000E95 488B742458              mov        rsi, [rsp+11*8]
  2347 00000E9A 488B542450              mov        rdx, [rsp+10*8]
  2348 00000E9F E8(00000000)            call       printf
  2349 00000EA4 B800000000              mov qword  rax, 0
  2350 00000EA9 48BF-                   mov        rdi, formatxmm4
  2351 00000EAB [CB0A000000000000] 
  2352 00000EB3 488B742448              mov        rsi, [rsp+9*8]
  2353 00000EB8 488B542440              mov        rdx, [rsp+8*8]
  2354 00000EBD E8(00000000)            call       printf
  2355 00000EC2 B800000000              mov qword  rax, 0
  2356 00000EC7 48BF-                   mov        rdi, formatxmm3
  2357 00000EC9 [E50A000000000000] 
  2358 00000ED1 488B742438              mov        rsi, [rsp+7*8]
  2359 00000ED6 488B542430              mov        rdx, [rsp+6*8]
  2360 00000EDB E8(00000000)            call       printf
  2361 00000EE0 B800000000              mov qword  rax, 0
  2362 00000EE5 48BF-                   mov        rdi, formatxmm2
  2363 00000EE7 [FF0A000000000000] 
  2364 00000EEF 488B742428              mov        rsi, [rsp+5*8]
  2365 00000EF4 488B542420              mov        rdx, [rsp+4*8]
  2366 00000EF9 E8(00000000)            call       printf
  2367 00000EFE B800000000              mov qword  rax, 0
  2368 00000F03 48BF-                   mov        rdi, formatxmm1
  2369 00000F05 [190B000000000000] 
  2370 00000F0D 488B742418              mov        rsi, [rsp+3*8]
  2371 00000F12 488B542410              mov        rdx, [rsp+2*8]
  2372 00000F17 E8(00000000)            call       printf
  2373 00000F1C B800000000              mov qword  rax, 0
  2374 00000F21 48BF-                   mov        rdi, formatxmm0
  2375 00000F23 [330B000000000000] 
  2376 00000F2B 488B742408              mov        rsi, [rsp+1*8]
  2377 00000F30 488B1424                mov        rdx, [rsp+0*8]
  2378 00000F34 E8(00000000)            call       printf
  2379                                  
  2380                                  ;========== Restore all the data to the SEE2 registers ===================================================================================
  2381                                  
  2382 00000F39 66440F10BC24F00000-     movupd     xmm15, [rsp+30*8]
  2383 00000F42 00                 
  2384 00000F43 66440F10B424E00000-     movupd     xmm14, [rsp+28*8]
  2385 00000F4C 00                 
  2386 00000F4D 66440F10AC24D00000-     movupd     xmm13, [rsp+26*8]
  2387 00000F56 00                 
  2388 00000F57 66440F10A424C00000-     movupd     xmm12, [rsp+24*8]
  2389 00000F60 00                 
  2390 00000F61 66440F109C24B00000-     movupd     xmm11, [rsp+22*8]
  2391 00000F6A 00                 
  2392 00000F6B 66440F109424A00000-     movupd     xmm10, [rsp+20*8]
  2393 00000F74 00                 
  2394 00000F75 66440F108C24900000-     movupd     xmm9,  [rsp+18*8]
  2395 00000F7E 00                 
  2396 00000F7F 66440F108424800000-     movupd     xmm8,  [rsp+16*8]
  2397 00000F88 00                 
  2398 00000F89 660F107C2470            movupd     xmm7,  [rsp+14*8]
  2399 00000F8F 660F10742460            movupd     xmm6,  [rsp+12*8]
  2400 00000F95 660F106C2450            movupd     xmm5,  [rsp+10*8]
  2401 00000F9B 660F10642440            movupd     xmm4,  [rsp+8*8]
  2402 00000FA1 660F105C2430            movupd     xmm3,  [rsp+6*8]
  2403 00000FA7 660F10542420            movupd     xmm2,  [rsp+4*8]
  2404 00000FAD 660F104C2410            movupd     xmm1,  [rsp+2*8]
  2405 00000FB3 660F100424              movupd     xmm0,  [rsp+0*8]
  2406                                  
  2407                                  ;========= Reverse the pushes that occurred in this subprogram ============================================================================
  2408 00000FB8 58                      pop rax                                                     ;#32
  2409 00000FB9 58                      pop rax                                                     ;#31
  2410 00000FBA 58                      pop rax                                                     ;#30
  2411 00000FBB 58                      pop rax                                                     ;#29
  2412 00000FBC 58                      pop rax                                                     ;#28
  2413 00000FBD 58                      pop rax                                                     ;#27
  2414 00000FBE 58                      pop rax                                                     ;#26
  2415 00000FBF 58                      pop rax                                                     ;#25
  2416 00000FC0 58                      pop rax                                                     ;#24
  2417 00000FC1 58                      pop rax                                                     ;#23
  2418 00000FC2 58                      pop rax                                                     ;#22
  2419 00000FC3 58                      pop rax                                                     ;#21
  2420 00000FC4 58                      pop rax                                                     ;#20
  2421 00000FC5 58                      pop rax                                                     ;#19
  2422 00000FC6 58                      pop rax                                                     ;#18
  2423 00000FC7 58                      pop rax                                                     ;#17
  2424 00000FC8 58                      pop rax                                                     ;#16
  2425 00000FC9 58                      pop rax                                                     ;#15
  2426 00000FCA 58                      pop rax                                                     ;#14
  2427 00000FCB 58                      pop rax                                                     ;#13
  2428 00000FCC 58                      pop rax                                                     ;#12
  2429 00000FCD 58                      pop rax                                                     ;#11
  2430 00000FCE 58                      pop rax                                                     ;#10
  2431 00000FCF 58                      pop rax                                                     ;#9
  2432 00000FD0 58                      pop rax                                                     ;#8
  2433 00000FD1 58                      pop rax                                                     ;#7
  2434 00000FD2 58                      pop rax                                                     ;#6
  2435 00000FD3 58                      pop rax                                                     ;#5
  2436 00000FD4 58                      pop rax                                                     ;#4
  2437 00000FD5 58                      pop rax                                                     ;#3
  2438 00000FD6 58                      pop rax                                                     ;#2
  2439 00000FD7 58                      pop rax                                                     ;#1
  2440                                  
  2441                                  ;=========== Restore the original values to the integer registers =========================================================================
  2442 00000FD8 9D                      popf                                                        ;Restore rflags
  2443 00000FD9 5B                      pop rbx                                                     ;Restore rbx
  2444 00000FDA 415F                    pop r15                                                     ;Restore r15
  2445 00000FDC 415E                    pop r14                                                     ;Restore r14
  2446 00000FDE 415D                    pop r13                                                     ;Restore r13
  2447 00000FE0 415C                    pop r12                                                     ;Restore r12
  2448 00000FE2 415B                    pop r11                                                     ;Restore r11
  2449 00000FE4 415A                    pop r10                                                     ;Restore r10
  2450 00000FE6 4159                    pop r9                                                      ;Restore r9
  2451 00000FE8 4158                    pop r8                                                      ;Restore r8
  2452 00000FEA 59                      pop rcx                                                     ;Restore rcx
  2453 00000FEB 5A                      pop rdx                                                     ;Restore rdx
  2454 00000FEC 5E                      pop rsi                                                     ;Restore rsi
  2455 00000FED 5F                      pop rdi                                                     ;Restore rdi
  2456 00000FEE 5D                      pop rbp                                                     ;Restore rbp
  2457                                  
  2458                                  ;========== Gently exit from this subprogram ==============================================================================================
  2459                                  
  2460 00000FEF B800000000              mov qword rax, 0                                            ;Return value 0 indicates successful conclusion.
  2461 00000FF4 C20800                  ret 8                                                       ;Return to the address on top of the stack and then discard one qword from the 
  2462                                  ;                                                           ;top of the stack.  The latter action is due to the '8' following the 'ret'.
  2463                                  
  2464                                  ;========== End of showxmmsubprogram ======================================================================================================
  2465                                  ;
  2466                                  ;==========================================================================================================================================
  2467                                  ;
  2468                                  ;                             Show YMM Registers Subprogram
  2469                                  ;
  2470                                  ;==========================================================================================================================================
  2471                                  ;
  2472                                  ;Subprogram name: showymmsubprogram
  2473                                  ;Language: X86
  2474                                  ;Syntax: Intel
  2475                                  ;Date begun: 2013-Nov-15
  2476                                  ;Date last modified: 2013-Nov-18
  2477                                  ;Purpose: Show the contents of all 16 ymm registers in the AVE component of SSE.
  2478                                  ;Strategy: The intent here is to damage no other register in the X86 CPU.
  2479                                  ;Terminology: AVE is Advanced Vector Extensions.  SSE is Streaming SIMD Extensions.  SIMD is Single Instruction - Multiple Data.  AVX is the component 
  2480                                  ;where 256-bit (32-byte) vector registers are found.  Such registers are labeled ymm0 through ymm15.  SSE is a subset of AVX where xmm registers are 
  2481                                  ;located.
  2482                                  
  2483                                  
  2484                                  global showymmsubprogram
  2485                                  
  2486                                  extern printf
  2487                                  
  2488                                  segment .data
  2489                                  
  2490 00000B4D 4156452044756D7020-     aveheaderfirst db "AVE Dump # %ld", 10, 0
  2491 00000B56 2320256C640A00     
  2492 00000B5D 202020202020207C2D-     aveheadersecond db "       |-----------------------------AVX Registers---------------------------------|", 10, 0
  2493 00000B66 2D2D2D2D2D2D2D2D2D-
  2494 00000B6F 2D2D2D2D2D2D2D2D2D-
  2495 00000B78 2D2D2D2D2D2D2D2D2D-
  2496 00000B81 2D4156582052656769-
  2497 00000B8A 73746572732D2D2D2D-
  2498 00000B93 2D2D2D2D2D2D2D2D2D-
  2499 00000B9C 2D2D2D2D2D2D2D2D2D-
  2500 00000BA5 2D2D2D2D2D2D2D2D2D-
  2501 00000BAE 2D2D7C0A00         
  2502 00000BB3 202020202020207C20-     aveheaderthird  db "       |                                                                           |", 10, 0
  2503 00000BBC 202020202020202020-
  2504 00000BC5 202020202020202020-
  2505 00000BCE 202020202020202020-
  2506 00000BD7 202020202020202020-
  2507 00000BE0 202020202020202020-
  2508 00000BE9 202020202020202020-
  2509 00000BF2 202020202020202020-
  2510 00000BFB 202020202020202020-
  2511 00000C04 20207C0A00         
  2512 00000C09 202020202020207C20-     aveheaderfourth db "       |                                    |-----------xmm registers------------| |", 10, 0
  2513 00000C12 202020202020202020-
  2514 00000C1B 202020202020202020-
  2515 00000C24 202020202020202020-
  2516 00000C2D 20202020202020207C-
  2517 00000C36 2D2D2D2D2D2D2D2D2D-
  2518 00000C3F 2D2D786D6D20726567-
  2519 00000C48 6973746572732D2D2D-
  2520 00000C51 2D2D2D2D2D2D2D2D2D-
  2521 00000C5A 7C207C0A00         
  2522 00000C5F 202020202020207C20-     aveheaderfifth  db "       |                                    |                                    | |", 10, 0
  2523 00000C68 202020202020202020-
  2524 00000C71 202020202020202020-
  2525 00000C7A 202020202020202020-
  2526 00000C83 20202020202020207C-
  2527 00000C8C 202020202020202020-
  2528 00000C95 202020202020202020-
  2529 00000C9E 202020202020202020-
  2530 00000CA7 202020202020202020-
  2531 00000CB0 7C207C0A00         
  2532 00000CB5 796D6D31353A207C20-     aveymm15        db "ymm15: | %016lx  %016lx | %016lx  %016lx | |", 10, 0
  2533 00000CBE 253031366C78202025-
  2534 00000CC7 3031366C78207C2025-
  2535 00000CD0 3031366C7820202530-
  2536 00000CD9 31366C78207C207C0A-
  2537 00000CE2 00                 
  2538 00000CE3 796D6D31343A207C20-     aveymm14        db "ymm14: | %016lx  %016lx | %016lx  %016lx | |", 10, 0
  2539 00000CEC 253031366C78202025-
  2540 00000CF5 3031366C78207C2025-
  2541 00000CFE 3031366C7820202530-
  2542 00000D07 31366C78207C207C0A-
  2543 00000D10 00                 
  2544 00000D11 796D6D31333A207C20-     aveymm13        db "ymm13: | %016lx  %016lx | %016lx  %016lx | |", 10, 0
  2545 00000D1A 253031366C78202025-
  2546 00000D23 3031366C78207C2025-
  2547 00000D2C 3031366C7820202530-
  2548 00000D35 31366C78207C207C0A-
  2549 00000D3E 00                 
  2550 00000D3F 796D6D31323A207C20-     aveymm12        db "ymm12: | %016lx  %016lx | %016lx  %016lx | |", 10, 0
  2551 00000D48 253031366C78202025-
  2552 00000D51 3031366C78207C2025-
  2553 00000D5A 3031366C7820202530-
  2554 00000D63 31366C78207C207C0A-
  2555 00000D6C 00                 
  2556 00000D6D 796D6D31313A207C20-     aveymm11        db "ymm11: | %016lx  %016lx | %016lx  %016lx | |", 10, 0
  2557 00000D76 253031366C78202025-
  2558 00000D7F 3031366C78207C2025-
  2559 00000D88 3031366C7820202530-
  2560 00000D91 31366C78207C207C0A-
  2561 00000D9A 00                 
  2562 00000D9B 796D6D31303A207C20-     aveymm10        db "ymm10: | %016lx  %016lx | %016lx  %016lx | |", 10, 0
  2563 00000DA4 253031366C78202025-
  2564 00000DAD 3031366C78207C2025-
  2565 00000DB6 3031366C7820202530-
  2566 00000DBF 31366C78207C207C0A-
  2567 00000DC8 00                 
  2568 00000DC9 796D6D393A20207C20-     aveymm9         db "ymm9:  | %016lx  %016lx | %016lx  %016lx | |", 10, 0
  2569 00000DD2 253031366C78202025-
  2570 00000DDB 3031366C78207C2025-
  2571 00000DE4 3031366C7820202530-
  2572 00000DED 31366C78207C207C0A-
  2573 00000DF6 00                 
  2574 00000DF7 796D6D383A20207C20-     aveymm8         db "ymm8:  | %016lx  %016lx | %016lx  %016lx | |", 10, 0
  2575 00000E00 253031366C78202025-
  2576 00000E09 3031366C78207C2025-
  2577 00000E12 3031366C7820202530-
  2578 00000E1B 31366C78207C207C0A-
  2579 00000E24 00                 
  2580 00000E25 796D6D373A20207C20-     aveymm7         db "ymm7:  | %016lx  %016lx | %016lx  %016lx | |", 10, 0
  2581 00000E2E 253031366C78202025-
  2582 00000E37 3031366C78207C2025-
  2583 00000E40 3031366C7820202530-
  2584 00000E49 31366C78207C207C0A-
  2585 00000E52 00                 
  2586 00000E53 796D6D363A20207C20-     aveymm6         db "ymm6:  | %016lx  %016lx | %016lx  %016lx | |", 10, 0
  2587 00000E5C 253031366C78202025-
  2588 00000E65 3031366C78207C2025-
  2589 00000E6E 3031366C7820202530-
  2590 00000E77 31366C78207C207C0A-
  2591 00000E80 00                 
  2592 00000E81 796D6D353A20207C20-     aveymm5         db "ymm5:  | %016lx  %016lx | %016lx  %016lx | |", 10, 0
  2593 00000E8A 253031366C78202025-
  2594 00000E93 3031366C78207C2025-
  2595 00000E9C 3031366C7820202530-
  2596 00000EA5 31366C78207C207C0A-
  2597 00000EAE 00                 
  2598 00000EAF 796D6D343A20207C20-     aveymm4         db "ymm4:  | %016lx  %016lx | %016lx  %016lx | |", 10, 0
  2599 00000EB8 253031366C78202025-
  2600 00000EC1 3031366C78207C2025-
  2601 00000ECA 3031366C7820202530-
  2602 00000ED3 31366C78207C207C0A-
  2603 00000EDC 00                 
  2604 00000EDD 796D6D333A20207C20-     aveymm3         db "ymm3:  | %016lx  %016lx | %016lx  %016lx | |", 10, 0
  2605 00000EE6 253031366C78202025-
  2606 00000EEF 3031366C78207C2025-
  2607 00000EF8 3031366C7820202530-
  2608 00000F01 31366C78207C207C0A-
  2609 00000F0A 00                 
  2610 00000F0B 796D6D323A20207C20-     aveymm2         db "ymm2:  | %016lx  %016lx | %016lx  %016lx | |", 10, 0
  2611 00000F14 253031366C78202025-
  2612 00000F1D 3031366C78207C2025-
  2613 00000F26 3031366C7820202530-
  2614 00000F2F 31366C78207C207C0A-
  2615 00000F38 00                 
  2616 00000F39 796D6D313A20207C20-     aveymm1         db "ymm1:  | %016lx  %016lx | %016lx  %016lx | |", 10, 0
  2617 00000F42 253031366C78202025-
  2618 00000F4B 3031366C78207C2025-
  2619 00000F54 3031366C7820202530-
  2620 00000F5D 31366C78207C207C0A-
  2621 00000F66 00                 
  2622 00000F67 796D6D303A20207C20-     aveymm0         db "ymm0:  | %016lx  %016lx | %016lx  %016lx | |", 10, 0
  2623 00000F70 253031366C78202025-
  2624 00000F79 3031366C78207C2025-
  2625 00000F82 3031366C7820202530-
  2626 00000F8B 31366C78207C207C0A-
  2627 00000F94 00                 
  2628 00000F95 202020202020207C2D-     avefooter       db "       |-------------------------------------------------------------------------|-|", 10, 0
  2629 00000F9E 2D2D2D2D2D2D2D2D2D-
  2630 00000FA7 2D2D2D2D2D2D2D2D2D-
  2631 00000FB0 2D2D2D2D2D2D2D2D2D-
  2632 00000FB9 2D2D2D2D2D2D2D2D2D-
  2633 00000FC2 2D2D2D2D2D2D2D2D2D-
  2634 00000FCB 2D2D2D2D2D2D2D2D2D-
  2635 00000FD4 2D2D2D2D2D2D2D2D2D-
  2636 00000FDD 2D2D2D2D2D2D2D2D2D-
  2637 00000FE6 7C2D7C0A00         
  2638                                  
  2639                                  segment .bxx
  2640                                  
  2641                                  segment .text
  2642                                  
  2643                                  showymmsubprogram:
  2644                                  
  2645                                  ;========== Back up the integer registers ===============================================================================================
  2646 00000FF7 55                      push       rbp
  2647 00000FF8 57                      push       rdi
  2648 00000FF9 56                      push       rsi
  2649 00000FFA 52                      push       rdx
  2650 00000FFB 51                      push       rcx
  2651 00000FFC 4150                    push       r8
  2652 00000FFE 4151                    push       r9
  2653 00001000 9C                      pushf
  2654                                  
  2655                                  ;========== Copy all ymm values to the integer stack ====================================================================================
  2656 00001001 90<rept>                align 16
  2657                                  
  2658 00001010 6A00                    push qword 0
  2659 00001012 6A00                    push qword 0
  2660 00001014 6A00                    push qword 0
  2661 00001016 6A00                    push qword 0
  2662 00001018 C57D113C24              vmovupd     [rsp], ymm15
  2663                                  
  2664 0000101D 6A00                    push qword 0
  2665 0000101F 6A00                    push qword 0
  2666 00001021 6A00                    push qword 0
  2667 00001023 6A00                    push qword 0
  2668 00001025 C57D113424              vmovupd     [rsp], ymm14
  2669                                  
  2670 0000102A 6A00                    push qword 0
  2671 0000102C 6A00                    push qword 0
  2672 0000102E 6A00                    push qword 0
  2673 00001030 6A00                    push qword 0
  2674 00001032 C57D112C24              vmovupd     [rsp], ymm13
  2675                                  
  2676 00001037 6A00                    push qword 0
  2677 00001039 6A00                    push qword 0
  2678 0000103B 6A00                    push qword 0
  2679 0000103D 6A00                    push qword 0
  2680 0000103F C57D112424              vmovupd     [rsp], ymm12
  2681                                  
  2682 00001044 6A00                    push qword 0
  2683 00001046 6A00                    push qword 0
  2684 00001048 6A00                    push qword 0
  2685 0000104A 6A00                    push qword 0
  2686 0000104C C57D111C24              vmovupd     [rsp], ymm11
  2687                                  
  2688 00001051 6A00                    push qword 0
  2689 00001053 6A00                    push qword 0
  2690 00001055 6A00                    push qword 0
  2691 00001057 6A00                    push qword 0
  2692 00001059 C57D111424              vmovupd     [rsp], ymm10
  2693                                  
  2694 0000105E 6A00                    push qword 0
  2695 00001060 6A00                    push qword 0
  2696 00001062 6A00                    push qword 0
  2697 00001064 6A00                    push qword 0
  2698 00001066 C57D110C24              vmovupd     [rsp], ymm9
  2699                                  
  2700 0000106B 6A00                    push qword 0
  2701 0000106D 6A00                    push qword 0
  2702 0000106F 6A00                    push qword 0
  2703 00001071 6A00                    push qword 0
  2704 00001073 C57D110424              vmovupd     [rsp], ymm8
  2705                                  
  2706 00001078 6A00                    push qword 0
  2707 0000107A 6A00                    push qword 0
  2708 0000107C 6A00                    push qword 0
  2709 0000107E 6A00                    push qword 0
  2710 00001080 C5FD113C24              vmovupd     [rsp], ymm7
  2711                                  
  2712 00001085 6A00                    push qword 0
  2713 00001087 6A00                    push qword 0
  2714 00001089 6A00                    push qword 0
  2715 0000108B 6A00                    push qword 0
  2716 0000108D C5FD113424              vmovupd     [rsp], ymm6
  2717                                  
  2718 00001092 6A00                    push qword 0
  2719 00001094 6A00                    push qword 0
  2720 00001096 6A00                    push qword 0
  2721 00001098 6A00                    push qword 0
  2722 0000109A C5FD112C24              vmovupd     [rsp], ymm5
  2723                                  
  2724 0000109F 6A00                    push qword 0
  2725 000010A1 6A00                    push qword 0
  2726 000010A3 6A00                    push qword 0
  2727 000010A5 6A00                    push qword 0
  2728 000010A7 C5FD112424              vmovupd     [rsp], ymm4
  2729                                  
  2730 000010AC 6A00                    push qword 0
  2731 000010AE 6A00                    push qword 0
  2732 000010B0 6A00                    push qword 0
  2733 000010B2 6A00                    push qword 0
  2734 000010B4 C5FD111C24              vmovupd     [rsp], ymm3
  2735                                  
  2736 000010B9 6A00                    push qword 0
  2737 000010BB 6A00                    push qword 0
  2738 000010BD 6A00                    push qword 0
  2739 000010BF 6A00                    push qword 0
  2740 000010C1 C5FD111424              vmovupd     [rsp], ymm2
  2741                                  
  2742 000010C6 6A00                    push qword 0
  2743 000010C8 6A00                    push qword 0
  2744 000010CA 6A00                    push qword 0
  2745 000010CC 6A00                    push qword 0
  2746 000010CE C5FD110C24              vmovupd     [rsp], ymm1
  2747                                  
  2748 000010D3 6A00                    push qword 0
  2749 000010D5 6A00                    push qword 0
  2750 000010D7 6A00                    push qword 0
  2751 000010D9 6A00                    push qword 0
  2752 000010DB C5FD110424              vmovupd     [rsp], ymm0
  2753                                  
  2754                                  
  2755                                  ;========== End of copying ymm values to the integer stack ==============================================================================
  2756                                  
  2757                                  ;========== Begin section that will display all the ymm values ==========================================================================
  2758                                  align 16
  2759 000010E0 B800000000              mov qword  rax, 0
  2760 000010E5 48BF-                   mov        rdi, aveheaderfirst
  2761 000010E7 [4D0B000000000000] 
  2762 000010EF 488BB42448020000        mov        rsi, [rsp+16*4*8+72]
  2763 000010F7 E8(00000000)            call       printf
  2764                                  
  2765 000010FC B800000000              mov qword  rax, 0
  2766 00001101 48BF-                   mov        rdi, aveheadersecond
  2767 00001103 [5D0B000000000000] 
  2768 0000110B E8(00000000)            call       printf
  2769                                  
  2770 00001110 B800000000              mov qword  rax, 0
  2771 00001115 48BF-                   mov        rdi, aveheaderthird
  2772 00001117 [B30B000000000000] 
  2773 0000111F E8(00000000)            call       printf
  2774                                  
  2775 00001124 B800000000              mov qword  rax, 0
  2776 00001129 48BF-                   mov        rdi, aveheaderfourth
  2777 0000112B [090C000000000000] 
  2778 00001133 E8(00000000)            call       printf
  2779                                  
  2780 00001138 B800000000              mov qword  rax, 0
  2781 0000113D 48BF-                   mov        rdi, aveheaderfifth
  2782 0000113F [5F0C000000000000] 
  2783 00001147 E8(00000000)            call       printf
  2784                                  
  2785 0000114C B800000000              mov qword  rax, 0
  2786 00001151 48BF-                   mov        rdi, aveymm15
  2787 00001153 [B50C000000000000] 
  2788 0000115B 488BB424F8010000        mov        rsi, [rsp+63*8]
  2789 00001163 488B9424F0010000        mov        rdx, [rsp+62*8]
  2790 0000116B 488B8C24E8010000        mov        rcx, [rsp+61*8]
  2791 00001173 4C8B8424E0010000        mov        r8,  [rsp+60*8]
  2792 0000117B E8(00000000)            call       printf
  2793                                  
  2794 00001180 B800000000              mov qword  rax, 0
  2795 00001185 48BF-                   mov        rdi, aveymm14
  2796 00001187 [E30C000000000000] 
  2797 0000118F 488BB424D8010000        mov        rsi, [rsp+59*8]
  2798 00001197 488B9424D0010000        mov        rdx, [rsp+58*8]
  2799 0000119F 488B8C24C8010000        mov        rcx, [rsp+57*8]
  2800 000011A7 4C8B8424C0010000        mov        r8,  [rsp+56*8]
  2801 000011AF E8(00000000)            call       printf
  2802                                  
  2803 000011B4 B800000000              mov qword  rax, 0
  2804 000011B9 48BF-                   mov        rdi, aveymm13
  2805 000011BB [110D000000000000] 
  2806 000011C3 488BB424B8010000        mov        rsi, [rsp+55*8]
  2807 000011CB 488B9424B0010000        mov        rdx, [rsp+54*8]
  2808 000011D3 488B8C24A8010000        mov        rcx, [rsp+53*8]
  2809 000011DB 4C8B8424A0010000        mov        r8,  [rsp+52*8]
  2810 000011E3 E8(00000000)            call       printf
  2811                                  
  2812 000011E8 B800000000              mov qword  rax, 0
  2813 000011ED 48BF-                   mov        rdi, aveymm12
  2814 000011EF [3F0D000000000000] 
  2815 000011F7 488BB42498010000        mov        rsi, [rsp+51*8]
  2816 000011FF 488B942490010000        mov        rdx, [rsp+50*8]
  2817 00001207 488B8C2488010000        mov        rcx, [rsp+49*8]
  2818 0000120F 4C8B842480010000        mov        r8,  [rsp+48*8]
  2819 00001217 E8(00000000)            call       printf
  2820                                  
  2821 0000121C B800000000              mov qword  rax, 0
  2822 00001221 48BF-                   mov        rdi, aveymm11
  2823 00001223 [6D0D000000000000] 
  2824 0000122B 488BB42478010000        mov        rsi, [rsp+47*8]
  2825 00001233 488B942470010000        mov        rdx, [rsp+46*8]
  2826 0000123B 488B8C2468010000        mov        rcx, [rsp+45*8]
  2827 00001243 4C8B842460010000        mov        r8,  [rsp+44*8]
  2828 0000124B E8(00000000)            call       printf
  2829                                  
  2830 00001250 B800000000              mov qword  rax, 0
  2831 00001255 48BF-                   mov        rdi, aveymm10
  2832 00001257 [9B0D000000000000] 
  2833 0000125F 488BB42458010000        mov        rsi, [rsp+43*8]
  2834 00001267 488B942450010000        mov        rdx, [rsp+42*8]
  2835 0000126F 488B8C2448010000        mov        rcx, [rsp+41*8]
  2836 00001277 4C8B842440010000        mov        r8,  [rsp+40*8]
  2837 0000127F E8(00000000)            call       printf
  2838                                  
  2839 00001284 B800000000              mov qword  rax, 0
  2840 00001289 48BF-                   mov        rdi, aveymm9
  2841 0000128B [C90D000000000000] 
  2842 00001293 488BB42438010000        mov        rsi, [rsp+39*8]
  2843 0000129B 488B942430010000        mov        rdx, [rsp+38*8]
  2844 000012A3 488B8C2428010000        mov        rcx, [rsp+37*8]
  2845 000012AB 4C8B842420010000        mov        r8,  [rsp+36*8]
  2846 000012B3 E8(00000000)            call       printf
  2847                                  
  2848 000012B8 B800000000              mov qword  rax, 0
  2849 000012BD 48BF-                   mov        rdi, aveymm8
  2850 000012BF [F70D000000000000] 
  2851 000012C7 488BB42418010000        mov        rsi, [rsp+35*8]
  2852 000012CF 488B942410010000        mov        rdx, [rsp+34*8]
  2853 000012D7 488B8C2408010000        mov        rcx, [rsp+33*8]
  2854 000012DF 4C8B842400010000        mov        r8,  [rsp+32*8]
  2855 000012E7 E8(00000000)            call       printf
  2856                                  
  2857 000012EC B800000000              mov qword  rax, 0
  2858 000012F1 48BF-                   mov        rdi, aveymm7
  2859 000012F3 [250E000000000000] 
  2860 000012FB 488BB424F8000000        mov        rsi, [rsp+31*8]
  2861 00001303 488B9424F0000000        mov        rdx, [rsp+30*8]
  2862 0000130B 488B8C24E8000000        mov        rcx, [rsp+29*8]
  2863 00001313 4C8B8424E0000000        mov        r8,  [rsp+28*8]
  2864 0000131B E8(00000000)            call       printf
  2865                                  
  2866 00001320 B800000000              mov qword  rax, 0
  2867 00001325 48BF-                   mov        rdi, aveymm6
  2868 00001327 [530E000000000000] 
  2869 0000132F 488BB424D8000000        mov        rsi, [rsp+27*8]
  2870 00001337 488B9424D0000000        mov        rdx, [rsp+26*8]
  2871 0000133F 488B8C24C8000000        mov        rcx, [rsp+25*8]
  2872 00001347 4C8B8424C0000000        mov        r8,  [rsp+24*8]
  2873 0000134F E8(00000000)            call       printf
  2874                                  
  2875 00001354 B800000000              mov qword  rax, 0
  2876 00001359 48BF-                   mov        rdi, aveymm5
  2877 0000135B [810E000000000000] 
  2878 00001363 488BB424B8000000        mov        rsi, [rsp+23*8]
  2879 0000136B 488B9424B0000000        mov        rdx, [rsp+22*8]
  2880 00001373 488B8C24A8000000        mov        rcx, [rsp+21*8]
  2881 0000137B 4C8B8424A0000000        mov        r8,  [rsp+20*8]
  2882 00001383 E8(00000000)            call       printf
  2883                                  
  2884 00001388 B800000000              mov qword  rax, 0
  2885 0000138D 48BF-                   mov        rdi, aveymm4
  2886 0000138F [AF0E000000000000] 
  2887 00001397 488BB42498000000        mov        rsi, [rsp+19*8]
  2888 0000139F 488B942490000000        mov        rdx, [rsp+18*8]
  2889 000013A7 488B8C2488000000        mov        rcx, [rsp+17*8]
  2890 000013AF 4C8B842480000000        mov        r8,  [rsp+16*8]
  2891 000013B7 E8(00000000)            call       printf
  2892                                  
  2893 000013BC B800000000              mov qword  rax, 0
  2894 000013C1 48BF-                   mov        rdi, aveymm3
  2895 000013C3 [DD0E000000000000] 
  2896 000013CB 488B742478              mov        rsi, [rsp+15*8]
  2897 000013D0 488B542470              mov        rdx, [rsp+14*8]
  2898 000013D5 488B4C2468              mov        rcx, [rsp+13*8]
  2899 000013DA 4C8B442460              mov        r8,  [rsp+12*8]
  2900 000013DF E8(00000000)            call       printf
  2901                                  
  2902 000013E4 B800000000              mov qword  rax, 0
  2903 000013E9 48BF-                   mov        rdi, aveymm2
  2904 000013EB [0B0F000000000000] 
  2905 000013F3 488B742458              mov        rsi, [rsp+11*8]
  2906 000013F8 488B542450              mov        rdx, [rsp+10*8]
  2907 000013FD 488B4C2448              mov        rcx, [rsp+9*8]
  2908 00001402 4C8B442440              mov        r8,  [rsp+8*8]
  2909 00001407 E8(00000000)            call       printf
  2910                                  
  2911 0000140C B800000000              mov qword  rax, 0
  2912 00001411 48BF-                   mov        rdi, aveymm1
  2913 00001413 [390F000000000000] 
  2914 0000141B 488B742438              mov        rsi, [rsp+7*8]
  2915 00001420 488B542430              mov        rdx, [rsp+6*8]
  2916 00001425 488B4C2428              mov        rcx, [rsp+5*8]
  2917 0000142A 4C8B442420              mov        r8,  [rsp+4*8]
  2918 0000142F E8(00000000)            call       printf
  2919                                  
  2920 00001434 B800000000              mov qword  rax, 0
  2921 00001439 48BF-                   mov        rdi, aveymm0
  2922 0000143B [670F000000000000] 
  2923 00001443 488B742418              mov        rsi, [rsp+3*8]
  2924 00001448 488B542410              mov        rdx, [rsp+2*8]
  2925 0000144D 488B4C2408              mov        rcx, [rsp+1*8]
  2926 00001452 4C8B0424                mov        r8,  [rsp+0*8]
  2927 00001456 E8(00000000)            call       printf
  2928                                  
  2929 0000145B B800000000              mov qword  rax, 0
  2930 00001460 48BF-                   mov        rdi, avefooter
  2931 00001462 [950F000000000000] 
  2932 0000146A E8(00000000)            call       printf
  2933                                  
  2934                                  ;========== End section that will display all the ymm values ============================================================================
  2935                                  
  2936                                  ;========== Restore the original data to the AVE registers ==============================================================================
  2937                                  
  2938                                  
  2939 0000146F C57D10BC24E0010000      vmovupd    ymm15, [rsp+60*8]
  2940 00001478 C57D10B424C0010000      vmovupd    ymm14, [rsp+56*8]
  2941 00001481 C57D10AC24A0010000      vmovupd    ymm13, [rsp+52*8]
  2942 0000148A C57D10A42480010000      vmovupd    ymm12, [rsp+48*8]
  2943 00001493 C57D109C2460010000      vmovupd    ymm11, [rsp+44*8]
  2944 0000149C C57D10942440010000      vmovupd    ymm10, [rsp+40*8]
  2945 000014A5 C57D108C2420010000      vmovupd    ymm9, [rsp+36*8]
  2946 000014AE C57D10842400010000      vmovupd    ymm8, [rsp+32*8]
  2947 000014B7 C5FD10BC24E0000000      vmovupd    ymm7, [rsp+28*8]
  2948 000014C0 C5FD10B424C0000000      vmovupd    ymm6, [rsp+24*8]
  2949 000014C9 C5FD10AC24A0000000      vmovupd    ymm5, [rsp+20*8]
  2950 000014D2 C5FD10A42480000000      vmovupd    ymm4, [rsp+16*8]
  2951 000014DB C5FD105C2460            vmovupd    ymm3, [rsp+12*8]
  2952 000014E1 C5FD10542440            vmovupd    ymm2, [rsp+8*8]
  2953 000014E7 C5FD104C2420            vmovupd    ymm1, [rsp+4*8]
  2954 000014ED C5FD100424              vmovupd    ymm0, [rsp+0*8]
  2955                                  
  2956                                  
  2957                                  ;========== Reverse the pushes that occurred in this subprogram ==========================================================================
  2958                                  
  2959                                  ;The instruction "push qword 0" has been executed 64 times earlier in this program.  Those 64 pushes could be reversed by 64 "pop rax",
  2960                                  ;but that will be exceedingly tedious.  Since each push is 8 bytes, the number of bytes pushed is 64 * 8 = 512.  Therefore, the plan is
  2961                                  ;to return the stack to its original state by adding 512 to the top pointer.  This one instruction will replace 64 pops.
  2962                                  
  2963 000014F2 4881C400020000          add rsp, 512
  2964                                  
  2965                                  
  2966                                  ;=========== Restore the former values to the integer registers =========================================================================
  2967                                  
  2968 000014F9 9D                      popf
  2969 000014FA 4159                    pop        r9
  2970 000014FC 4158                    pop        r8
  2971 000014FE 59                      pop        rcx
  2972 000014FF 5A                      pop        rdx
  2973 00001500 5E                      pop        rsi
  2974 00001501 5F                      pop        rdi
  2975 00001502 5D                      pop        rbp
  2976                                  
  2977                                  ;========== Exit gently from this subprogram ============================================================================================
  2978                                  
  2979 00001503 B800000000              mov qword  rax, 0
  2980 00001508 C20800                  ret        8                                                ;Go to the address on top of the stack, and then discard 8 from the stack.
  2981                                  
  2982                                  ;========== End of showymmsubprogram ====================================================================================================
  2983                                  
  2984                                  
  2985                                  ;========== Begin subprogram backupsse ==================================================================================================
  2986                                  ;Author: F. Holliday
  2987                                  ;Email: activeprofessor@yahoo.com
  2988                                  ;Course: CPSC240-MWF
  2989                                  ;Assignment number:
  2990                                  ;Due date: December 23, 2013
  2991                                  ;File name: 
  2992                                  ;Program name: backupsse
  2993                                  ;Language: X86-64
  2994                                  ;Syntax: Intel
  2995                                  ;Last update: 2013-Aug-28
  2996                                  ;Page width maximum: 140 columns
  2997                                  ;Comments begin at column: 61
  2998                                  ;Statement of Purpose:  This program is a utility subprogram.  Its function is to copy all 16 xmm registers to the integer stack.  For each
  2999                                  ;register both the upper quadword and the lower quadword will be backed up on the integer stack.
  3000                                  ;References:
  3001                                  ;Credits: None
  3002                                  ;Status: Alpha testing
  3003                                  
  3004                                  ;Permission: The source code is free for use by members of the 240 programming course.  You should credit the source where you obtained 
  3005                                  ;            the assembly instructions.  Notice that it says the instructions are free for you to use in any manner.  The comments are 
  3006                                  ;            personal text belonging to the author.  You create your own comments.  That is how intellectual property works.
  3007                                  
  3008                                  ;Conditions for the caller of backupsse
  3009                                  ;Preconditions: none
  3010                                  ;Postconditions: (1) The data in all SSE2 registers are backed up in the integer stack.
  3011                                  ; (2) The value in rax has probably changed
  3012                                  ; (3) The calling program is required to restore the integer stack to the state it had immediately before backupsse was called.  This may 
  3013                                  ;     be accomplished post-calling to backupsse by calling the compliment subprogram restoresse provided that between the call to 
  3014                                  ;     backupsse and the call to restoresse the number of bytes pushed equals the number of bytes popped.
  3015                                  
  3016                                  
  3017                                  ;Assemble: NA
  3018                                  
  3019                                  ;========== Begin code area ===============================================================================================================
  3020                                  
  3021                                  global backupsse                                            ;Future proofing.  Global declaration allows programs outside of this file to 
  3022                                                                                              ;to call backupsse.
  3023                                  
  3024                                  segment .data                                               ;This segment holds initialized data declarations
  3025                                  ;This segment is empty
  3026                                  
  3027                                  segment .bss                                                ;This segment holds un-initialized data declarations
  3028                                  ;This segment is empty
  3029                                  
  3030                                  segment .text                                               ;This segment holds executable instructions
  3031                                  
  3032                                  backupsse:                                                  ;This is the entry point where execution will begin
  3033                                  
  3034 0000150B 58                      pop        rax                                              ;Remove from the stack the return address and store it in rax for later use
  3035                                  
  3036 0000150C 90<rept>                align 16                                                    ;The next instruction will begin on a 16-byte boundary.
  3037 00001510 6A00                    push qword 0                                                ;Use two pushes to create 16 bytes of storage.
  3038 00001512 6A00                    push qword 0
  3039 00001514 66440F113C24            movupd     [rsp], xmm15                                     ;Copy xmm15 to the newly created storage.
  3040 0000151A 6A00                    push qword 0                                                ;Use two pushes to create 16 bytes of storage.
  3041 0000151C 6A00                    push qword 0
  3042 0000151E 66440F113424            movupd     [rsp], xmm14
  3043 00001524 6A00                    push qword 0                                                ;Use two pushes to create 16 bytes of storage.
  3044 00001526 6A00                    push qword 0
  3045 00001528 66440F112C24            movupd     [rsp], xmm13
  3046 0000152E 6A00                    push qword 0                                                ;Use two pushes to create 16 bytes of storage.
  3047 00001530 6A00                    push qword 0
  3048 00001532 66440F112424            movupd     [rsp], xmm12
  3049 00001538 6A00                    push qword 0                                                ;Use two pushes to create 16 bytes of storage.
  3050 0000153A 6A00                    push qword 0
  3051 0000153C 66440F111C24            movupd     [rsp], xmm11
  3052 00001542 6A00                    push qword 0                                                ;Use two pushes to create 16 bytes of storage.
  3053 00001544 6A00                    push qword 0
  3054 00001546 66440F111424            movupd     [rsp], xmm10
  3055 0000154C 6A00                    push qword 0                                                ;Use two pushes to create 16 bytes of storage.
  3056 0000154E 6A00                    push qword 0
  3057 00001550 66440F110C24            movupd     [rsp], xmm9
  3058 00001556 6A00                    push qword 0                                                ;Use two pushes to create 16 bytes of storage.
  3059 00001558 6A00                    push qword 0
  3060 0000155A 66440F110424            movupd     [rsp], xmm8
  3061 00001560 6A00                    push qword 0                                                ;Use two pushes to create 16 bytes of storage.
  3062 00001562 6A00                    push qword 0
  3063 00001564 660F113C24              movupd     [rsp], xmm7
  3064 00001569 6A00                    push qword 0                                                ;Use two pushes to create 16 bytes of storage.
  3065 0000156B 6A00                    push qword 0
  3066 0000156D 660F113424              movupd     [rsp], xmm6
  3067 00001572 6A00                    push qword 0                                                ;Use two pushes to create 16 bytes of storage.
  3068 00001574 6A00                    push qword 0
  3069 00001576 660F112C24              movupd     [rsp], xmm5
  3070 0000157B 6A00                    push qword 0                                                ;Use two pushes to create 16 bytes of storage.
  3071 0000157D 6A00                    push qword 0
  3072 0000157F 660F112424              movupd     [rsp], xmm4
  3073 00001584 6A00                    push qword 0                                                ;Use two pushes to create 16 bytes of storage.
  3074 00001586 6A00                    push qword 0
  3075 00001588 660F111C24              movupd     [rsp], xmm3
  3076 0000158D 6A00                    push qword 0                                                ;Use two pushes to create 16 bytes of storage.
  3077 0000158F 6A00                    push qword 0
  3078 00001591 660F111424              movupd     [rsp], xmm2
  3079 00001596 6A00                    push qword 0                                                ;Use two pushes to create 16 bytes of storage.
  3080 00001598 6A00                    push qword 0
  3081 0000159A 660F110C24              movupd     [rsp], xmm1
  3082 0000159F 6A00                    push qword 0                                                ;Use two pushes to create 16 bytes of storage.
  3083 000015A1 6A00                    push qword 0
  3084 000015A3 660F110424              movupd     [rsp], xmm0
  3085                                  
  3086 000015A8 50                      push       rax                                              ;Return a copy of the return address to the top of the integer stack
  3087 000015A9 C3                      ret                                                         ;Pop the return address from the stack and go there to resume execution.
  3088                                  ;========== End subprogram backupsse ======================================================================================================
  3089                                  
  3090                                  
  3091                                  ;========== Begin subprogram restoresse ===================================================================================================
  3092                                  
  3093                                  ;Author: F. Holliday
  3094                                  ;Email: activeprofessor@yahoo.com
  3095                                  ;Course: CPSC240-MWF
  3096                                  ;Assignment number:
  3097                                  ;Due date: December 23, 2013
  3098                                  ;File name:
  3099                                  ;Program name: restoresse
  3100                                  ;Language: X86-64
  3101                                  ;Syntax: Intel
  3102                                  ;Last update: 2013-Aug-28
  3103                                  ;Page width maximum: 140 columns
  3104                                  ;Comments begin at column: 61
  3105                                  ;Statement of Purpose:  This program is a utility subprogram.  Its function is to copy previously stored data from the integer stack to
  3106                                  ;each of the SSE registers.  This backup function includes both upper and lower quadword of each register.  This subprogram is to be used
  3107                                  ;in conjunction with the companion program backupsse.
  3108                                  ;References:
  3109                                  ;Credits: None
  3110                                  ;Status: Alpha testing
  3111                                  
  3112                                  ;Permission: The source code is free for use by members of the 240 programming course.  You should credit the source where you obtained 
  3113                                  ;            the assembly instructions.  Notice that it says the instructions are free for you to use in any manner.  The comments are 
  3114                                  ;            personal text belonging to the author.  You create your own comments.  That is how intellectual property works.
  3115                                  
  3116                                  ;Conditions for the caller of backupsse
  3117                                  ;Preconditions: (1) The caller did previously call the companion program backupsse.
  3118                                  ; (2) Between the point where backupsse was called and the point where restoresse is called the number of bytes pushed equals the number
  3119                                  ;     of bytes popped. 
  3120                                  ;Postconditions: (1) The previously backed up data from SSE resgisters are restored to SSE registers.
  3121                                  ; (2) The value in rax has probably changed.  The caller should not rely on rax maintaining it previous value.
  3122                                  
  3123                                  ;Assemble: NA
  3124                                  
  3125                                  ;========== Begin code area ===============================================================================================================
  3126                                  
  3127                                  global restoresse                                           ;Future proofing.  Global declaration allows programs outside of this file to 
  3128                                                                                              ;to call backupsse.
  3129                                  
  3130                                  segment .data                                               ;This segment holds initialized data declarations
  3131                                  ;This segment is empty
  3132                                  
  3133                                  segment .bss                                                ;This segment holds un-initialized data declarations
  3134                                  ;This segment is empty
  3135                                  
  3136                                  segment .text                                               ;This segment holds executable instructions
  3137                                  
  3138                                  restoresse:                                                 ;This is the entry point where execution will begin
  3139                                  
  3140 000015AA 58                      pop        rax                                              ;Remove from the stack the return address and store it in rax for later use
  3141                                  
  3142 000015AB 90<rept>                align 16                                                    ;The next instruction will begin on a 16-byte boundary.
  3143                                  
  3144                                  ;========== Restore all the data to the SEE2 registers ===================================================================================
  3145                                  
  3146 000015B0 66440F10BC24F00000-     movupd     xmm15, [rsp+30*8]
  3147 000015B9 00                 
  3148 000015BA 66440F10B424E00000-     movupd     xmm14, [rsp+28*8]
  3149 000015C3 00                 
  3150 000015C4 66440F10AC24D00000-     movupd     xmm13, [rsp+26*8]
  3151 000015CD 00                 
  3152 000015CE 66440F10A424C00000-     movupd     xmm12, [rsp+24*8]
  3153 000015D7 00                 
  3154 000015D8 66440F109C24B00000-     movupd     xmm11, [rsp+22*8]
  3155 000015E1 00                 
  3156 000015E2 66440F109424A00000-     movupd     xmm10, [rsp+20*8]
  3157 000015EB 00                 
  3158 000015EC 66440F108C24900000-     movupd     xmm9,  [rsp+18*8]
  3159 000015F5 00                 
  3160 000015F6 66440F108424800000-     movupd     xmm8,  [rsp+16*8]
  3161 000015FF 00                 
  3162 00001600 660F107C2470            movupd     xmm7,  [rsp+14*8]
  3163 00001606 660F10742460            movupd     xmm6,  [rsp+12*8]
  3164 0000160C 660F106C2450            movupd     xmm5,  [rsp+10*8]
  3165 00001612 660F10642440            movupd     xmm4,  [rsp+8*8]
  3166 00001618 660F105C2430            movupd     xmm3,  [rsp+6*8]
  3167 0000161E 660F10542420            movupd     xmm2,  [rsp+4*8]
  3168 00001624 660F104C2410            movupd     xmm1,  [rsp+2*8]
  3169 0000162A 660F100424              movupd     xmm0,  [rsp+0*8]
  3170                                  
  3171                                  ;========== Remove all the SEE data from the integer stack ===============================================================================
  3172                                  
  3173                                  ;The data could be removed via 32 pops of qwords into rax.  However, rax is holding the important return address; therefore, it is not
  3174                                  ;a good idea to modify rax.  Here we used the more direct and somewhat more obscure techniques of simply moving the top of stack by 
  3175                                  ;32*8 = 256 bytes.
  3176                                  
  3177 0000162F 4881C400010000          add        rsp, 256
  3178                                  
  3179                                  ;=========== Restore the return address and quietly leave this subprogram =================================================================
  3180                                  
  3181 00001636 50                      push       rax
  3182                                  
  3183 00001637 C3                      ret                                                         ;Get the address from the top of the stack and resume execution there.
  3184                                  
  3185                                  ;========== End of subprogram restoresse ==================================================================================================
  3186                                  
  3187                                  
  3188                                  
  3189                                  ;========== Begin footnotes ===============================================================================================================
  3190                                  ;From Professional Assembly Language by Richard Blum, page 241.
  3191                                  ;The tag register is used to identify the values with the eight 80-bit FPU data registers.  The tag register uses 16 bits (2 bits per register) to identify
  3192                                  ;the contents of each FPU data registers.  See figure below.
  3193                                  ;
  3194                                  ;Bits:                   15&14 13&12 11&10 9&8 7&6 5&4 3&2 1&0
  3195                                  ;Physical registers:      R7    R6    R5   R4  R3  R2  R1  R0
  3196                                  ;
  3197                                  ;Each tag value corresponds to a physical FPU register.  The 2-bit value for each register can contain on of four special codes indicating the content of the
  3198                                  ;register.  At any given time, an FPU data register can contain any one of the following "tags":
  3199                                      ;code 00:  a valid extended value
  3200                                      ;code 01:  the value zero
  3201                                      ;code 10:  one of the special fp value: denormal, infinity, or nan
  3202                                      ;code 11:  empty [free space, probably a nan]
  3203                                  ;This enables programmers to perform a quick check of the tag register to determine whether valid data may be in an FPU register, instead of having to read 
  3204                                  ;and analyze the contents of the register, although in practice, because you are the one putting the values into the register stack, you should already know 
  3205                                  ;what is there.
  3206                                  ;==========================================================================================================================================
  3207                                  
  3208                                  
